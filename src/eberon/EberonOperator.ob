MODULE EberonOperator;
IMPORT Cast, Code, CodePrecedence, EberonMap, LanguageContext, OberonRtl, Operator, Types;
TYPE
    CastOpRecord = RECORD(Cast.CastOpRecord)
    END;
VAR
    castOperations*: Cast.Operations;

PROCEDURE opAddStr(left, right: Code.PConst): Code.PConst;
    RETURN Code.makeStringConst(left^(Code.StringConst).value
                              + right^(Code.StringConst).value)
END opAddStr;

PROCEDURE opEqualStr(left, right: Code.PConst): Code.PConst;
    RETURN Code.makeIntConst(ORD(left^(Code.StringConst).value
                                 = right^(Code.StringConst).value))
END opEqualStr;

PROCEDURE opNotEqualStr(left, right: Code.PConst): Code.PConst;
    RETURN Code.makeIntConst(ORD(left^(Code.StringConst).value
                                 # right^(Code.StringConst).value))
END opNotEqualStr;

PROCEDURE opLessStr(left, right: Code.PConst): Code.PConst;
    RETURN Code.makeIntConst(ORD(left^(Code.StringConst).value
                               < right^(Code.StringConst).value))
END opLessStr;

PROCEDURE opGreaterStr(left, right: Code.PConst): Code.PConst;
    RETURN Code.makeIntConst(ORD(left^(Code.StringConst).value
                               > right^(Code.StringConst).value))
END opGreaterStr;

PROCEDURE opLessEqualStr(left, right: Code.PConst): Code.PConst;
    RETURN Code.makeIntConst(ORD(left^(Code.StringConst).value
                              <= right^(Code.StringConst).value))
END opLessEqualStr;

PROCEDURE opGraterEqualStr(left, right: Code.PConst): Code.PConst;
    RETURN Code.makeIntConst(ORD(left^(Code.StringConst).value
                              >= right^(Code.StringConst).value))
END opGraterEqualStr;

PROCEDURE addStr*(left, right: Code.PExpression): Code.PExpression;
    RETURN Operator.binaryWithCode(left, right, opAddStr, " + ", CodePrecedence.addSub)
END addStr;

PROCEDURE equalStr*(left, right: Code.PExpression): Code.PExpression;
    RETURN Operator.equal(left, right, opEqualStr, " == ")
END equalStr;

PROCEDURE notEqualStr*(left, right: Code.PExpression): Code.PExpression;
    RETURN Operator.equal(left, right, opNotEqualStr, " != ")
END notEqualStr;

PROCEDURE lessStr*(left, right: Code.PExpression): Code.PExpression;
    RETURN Operator.relational(left, right, opLessStr, " < ")
END lessStr;

PROCEDURE greaterStr*(left, right: Code.PExpression): Code.PExpression;
    RETURN Operator.relational(left, right, opGreaterStr, " > ")
END greaterStr;

PROCEDURE lessEqualStr*(left, right: Code.PExpression): Code.PExpression;
    RETURN Operator.relational(left, right, opLessEqualStr, " <= ")
END lessEqualStr;

PROCEDURE greaterEqualStr*(left, right: Code.PExpression): Code.PExpression;
    RETURN Operator.relational(left, right, opGraterEqualStr, " >= ")
END greaterEqualStr;

PROCEDURE inMap*(left, right: Code.PExpression; rtl: OberonRtl.PType): Code.PExpression;
    RETURN Code.makeSimpleExpression("Object.prototype.hasOwnProperty.call(" + right.code() + ", " + left.code() + ")",
                                     Types.basic.bool);
END;

PROCEDURE generateTypeInfo*(type: Types.PType): STRING;
VAR
    result: STRING;
BEGIN
    IF type IS EberonMap.PType THEN
        result := "{map: " + generateTypeInfo(type.valueType) + "}";
    ELSE
        result := Types.generateTypeInfo(type);
    END;
    RETURN result;
END;

PROCEDURE CastOpRecord.assign(cx: LanguageContext.PType; left, right: Code.PExpression): STRING;
VAR
    result: STRING;
BEGIN
    leftCode <- left.code();
    leftLval <- left.lval();
    IF leftCode # leftLval THEN (* TRUE for putting to MAP *)
        (* optimize the case when the temporary is used - do not clone it 
           but only if types exactly match - derived temporary still must be cloned *)
        IF (right.designator() = NIL) & (left.type() = right.type()) THEN
            result := leftLval + " = " + right.code();
        ELSE
            result := leftLval + " = " + cx.rtl.clone(right.code(), 
                                                      generateTypeInfo(left.type()), 
                                                      Types.recordConstructor(cx^, left.type()(Types.PRecord)^));
        END;
    ELSE
        result := SUPER(cx, left, right);
    END;
    RETURN result;
END;

BEGIN
    castOperations.castToUint8 := NEW Operator.CastToUint8();
    castOperations.castToRecord := NEW CastOpRecord();
END EberonOperator.