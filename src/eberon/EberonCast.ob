MODULE EberonCast;
IMPORT Cast, Code, EberonString, EberonDynamicArray, OberonRtl, Operator, Types;
TYPE
    CastOpToDynamicArray = RECORD (Cast.CastOp)
    END;

VAR
    castOpToDynamicArray: POINTER TO CastOpToDynamicArray;

PROCEDURE CastOpToDynamicArray.make(rtl: OberonRtl.PType; e: Code.PExpression): Code.PExpression;
    RETURN Code.makeSimpleExpression(Operator.cloneArray(e.type()(Types.PArray)^, e.code(), rtl^), NIL)
END CastOpToDynamicArray.make;

PROCEDURE isOpenCharArray(type: Types.PType): BOOLEAN;
    RETURN (type IS Types.POpenArray) 
         & (Types.arrayElementsType(type^) = Types.basic.ch)
END isOpenCharArray;

PROCEDURE implicit*(from, to: Types.PType; toVar: BOOLEAN; ops: Cast.Operations; VAR op: Cast.PCastOp): INTEGER;
VAR
    result: INTEGER;
BEGIN
    IF   ((from = EberonString.string) & ((to IS Types.PString) OR isOpenCharArray(to))
      OR ((from IS Types.PString) & (to = EberonString.string))) THEN
        IF toVar THEN 
            result := Cast.errVarParameter;
        ELSE
            result := Cast.errNo;
        END;
    ELSIF (from IS Types.PArray) & (to IS EberonDynamicArray.PDynamicArray)
        & Cast.areTypesExactlyMatch(Types.arrayElementsType(from^), 
                                    Types.arrayElementsType(to^)) THEN
        IF toVar & ~(from IS EberonDynamicArray.PDynamicArray) THEN
            result := Cast.errVarParameter;
        ELSE
            op := castOpToDynamicArray;
            result := Cast.errNo;
        END;
    ELSE
        result := Cast.implicit(from, to, toVar, ops, op);
    END;
    RETURN result
END implicit;

BEGIN
    NEW(castOpToDynamicArray);
END EberonCast.