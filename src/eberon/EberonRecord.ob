MODULE EberonRecord;
IMPORT 
    Cast, Context, EberonContext, EberonTypes, Errors, JS, JsMap, Object, Scope, ScopeBase, Stream, String, Types;
CONST
    instantiateForVar* = 0;    
    instantiateForNew* = 1;    
    instantiateForCopy* = 2;    
TYPE
    Record* = RECORD(Types.Record)
        PROCEDURE Record(name: STRING; cons: STRING; scope: ScopeBase.PType);

        PROCEDURE declareConstructor(type: Types.PDefinedProcedure; exported: BOOLEAN);
        PROCEDURE addMethod(methodId: Context.PIdentdefInfo; type: Types.PProcedure);
        PROCEDURE defineConstructor(type: Types.PDefinedProcedure);
        PROCEDURE defineMethod(methodId: Context.PIdentdefInfo; type: EberonTypes.PMethodType);
        PROCEDURE requireNewOnly();
        PROCEDURE setBaseConstructorCallCode(code: STRING);
        PROCEDURE setFieldInitializationCode(field: STRING; code: STRING);
        PROCEDURE setRecordInitializationCode(baseConstructorCallCode: STRING);

        customConstructor-: Types.PDefinedProcedure;
        customConstructorExported: BOOLEAN;
        customConstructorDefined: BOOLEAN;
        customInitedfields-: ARRAY * OF STRING;
        finalized: BOOLEAN;
        declaredMethods: JsMap.Type;
        definedMethods: ARRAY * OF STRING;
        abstractMethods: ARRAY * OF STRING;
        instantiated: BOOLEAN;
        createByNewOnly: BOOLEAN;
        declaredAsVariable: BOOLEAN;
        lazyDefinitions: JsMap.Type;
        nonExportedMethods: ARRAY * OF STRING;
        baseConstructorCallCode-: STRING;
        fieldsInit: JsMap.Strings;
        fieldsInitOrder: ARRAY * OF STRING;
        lastFieldInit: INTEGER;
    END;
    PRecord* = POINTER TO Record;

    RecordField* = RECORD(Types.RecordField)
        PROCEDURE RecordField*(identdef: Context.PIdentdefInfo; type: Types.PType; record: PRecord);

        record: PRecord;
    END;

    RecordFieldAsMethod = RECORD(Types.RecordField)
    END;
    PRecordFieldAsMethod = POINTER TO RecordFieldAsMethod;

    MethodIds = RECORD(Object.Type)
        ids: ARRAY * OF STRING;
    END;
    PMethodIds = POINTER TO MethodIds;

    EnsureMethodDefinitionsClosure = RECORD(Object.Type)
        record: PRecord;
        result: ARRAY * OF STRING;
    END;

    RequireMethodDefinitionClosure = RECORD(Object.Type)
        record: PRecord;
        base: PRecord;
    END;

    GenFieldInitCodeClosure = RECORD(Object.Type)
        cx: Context.PType;
        record: PRecord;
        code: STRING;
    END;

PROCEDURE cannotInstantiateErrMsg(r: Types.Record): STRING;
    RETURN "cannot instantiate '" 
         + r.name 
         + "' because it has abstract method(s)";
END;

PROCEDURE hasMethodDefinition(r: PRecord; id: STRING): BOOLEAN;
BEGIN
    type <- r;
    WHILE (type # NIL) & (type.definedMethods.indexOf(id) = -1) DO
        type := type.base(PRecord);
    END;
    RETURN type # NIL;
END;

PROCEDURE findMethodDeclaration(r: PRecord; id: STRING): Types.PField;
VAR
    result: Object.PType;
BEGIN
    type <- r;
    WHILE (type # NIL) & ~JsMap.find(type.declaredMethods, id, result) DO
        type := type.base(PRecord);
    END;
    RETURN result(Types.PField);
END;

PROCEDURE ensureMethodDefinitionsForEach(key: STRING; value: Object.PType; VAR closure: Object.Type);
    PROCEDURE do(ids: ARRAY OF STRING; closure: EnsureMethodDefinitionsClosure);
    VAR
        report: ARRAY * OF STRING;
    BEGIN
        FOR i <- 0 TO LEN(ids) - 1 DO
            m <- ids[i];
            IF ~hasMethodDefinition(closure.record, m) THEN
                report.add(m);
            END;
        END;

        IF LEN(report) # 0 THEN
            closure.result.add(key + ": " + String.join(report, ", "));
        END;
    END;
BEGIN
    do(value(PMethodIds).ids, closure(EnsureMethodDefinitionsClosure));
END;

PROCEDURE ensureMethodDefinitions(r: PRecord; reasons: JsMap.Type);
VAR
    closure: EnsureMethodDefinitionsClosure;
BEGIN
    closure.record := r;
    JsMap.forEach(reasons, ensureMethodDefinitionsForEach, closure);
    IF LEN(closure.result) # 0 THEN
        Errors.raise(String.join(closure.result, "; "));
    END;
END;

PROCEDURE requireMethodDefinition*(r: PRecord; id: STRING; reason: STRING);
VAR
    existingIds: Object.PType;

    PROCEDURE makeIds(): PMethodIds;
    BEGIN
        result <- NEW MethodIds();
        result.ids.add(id);
        RETURN result;
    END;

    PROCEDURE addIfNotThere(VAR ids: ARRAY * OF STRING);
    BEGIN
        IF ids.indexOf(id) = -1 THEN
            ids.add(id);
        END;
    END;

BEGIN
    IF findMethodDeclaration(r, id) = NIL THEN
        Errors.raise("there is no method '" + id + "' in base type(s)");
    END;

    IF r.finalized THEN
        reasons <- JsMap.make();
        JsMap.put(reasons, reason, makeIds());
        ensureMethodDefinitions(r, reasons);
    ELSE
        IF ~JsMap.find(r.lazyDefinitions, reason, existingIds) THEN
            JsMap.put(r.lazyDefinitions, reason, makeIds());
        ELSE
            addIfNotThere(existingIds(PMethodIds).ids);
        END;
    END;
END;

PROCEDURE requireMethodDefinitionForEach(key: STRING; value: Object.PType; VAR closure: Object.Type);
    PROCEDURE do(closure: RequireMethodDefinitionClosure);
    BEGIN
        IF ~hasMethodDefinition(closure.record, key) THEN
            requireMethodDefinition(closure.base, key, cannotInstantiateErrMsg(closure.record^));
        END;
    END;
BEGIN
    do(closure(RequireMethodDefinitionClosure));
END;

PROCEDURE ensureNonAbstract(r: PRecord);
VAR
    closure: RequireMethodDefinitionClosure;
BEGIN
    IF LEN(r.abstractMethods) # 0 THEN
        Errors.raise(cannotInstantiateErrMsg(r^) + ": " + String.join(r.abstractMethods, ", "));
    END;

    baseType <- r.base(PRecord);
    closure.record := r;
    WHILE baseType # NIL DO
        IF ~baseType.finalized THEN
            closure.base := baseType;
            JsMap.forEach(baseType.declaredMethods, requireMethodDefinitionForEach, closure);
        END;
        baseType := baseType.base(PRecord);
    END;
END;

PROCEDURE ensureVariableCanBeDeclared(r: PRecord);
BEGIN
    type <- r;
    WHILE type # NIL DO
        IF type.createByNewOnly THEN
            Errors.raise(
                    "cannot declare a variable of type '" 
                  + type.name + "' (and derived types) "
                  + "because SELF(POINTER) was used in its method(s)");
        END;
        type := type.base(PRecord);
    END;
END;

PROCEDURE RecordFieldAsMethod.asVar(isReadOnly: BOOLEAN; cx: Context.Type): Types.PId;
    RETURN NEW EberonTypes.MethodVariable(SELF.type()); 
END;

PROCEDURE constructor*(r: Record): Types.PDefinedProcedure;
BEGIN
    result <- r.customConstructor;
    IF (result = NIL) & (r.base # NIL) THEN
        result := constructor(r.base(PRecord)^);
    END;
    RETURN result;
END;

PROCEDURE hasParameterizedConstructor*(r: Record): BOOLEAN;
BEGIN
    c <- constructor(r);
    RETURN (c # NIL) & (LEN(c.args()) # 0);
END;

PROCEDURE canBeCreatedInAnotherModule(r: Record): BOOLEAN;
    RETURN (r.customConstructor = NIL) OR r.customConstructorExported;
END;

PROCEDURE canBeCreatedInContext(cx: Context.Type; r: Record): BOOLEAN;
    RETURN (LEN(cx.qualifyScope(r.scope)) = 0)
        OR canBeCreatedInAnotherModule(r);
END;

PROCEDURE Record.setBase(type: Types.PRecord);
BEGIN
    IF (type.scope # SELF.scope) & (SELF.scope^ IS Scope.Module) 
        & ~canBeCreatedInAnotherModule(type(PRecord)^) THEN
        Errors.raise("cannot extend '" + type.name + "' - its constructor was not exported")
    END;
    SUPER(type);
END;

PROCEDURE ensureCanBeInstantiated*(cx: Context.Type; r: PRecord; type: INTEGER);
BEGIN
    IF r.finalized THEN
        ensureNonAbstract(r);
        IF (type # instantiateForCopy) & ~canBeCreatedInContext(cx, r^) THEN
            Errors.raise("cannot instantiate '" + r.name + "' - its constructor was not exported");
        END;

        IF type # instantiateForNew THEN
            ensureVariableCanBeDeclared(r);
        END;
    ELSE
        r.instantiated := TRUE;
        IF type # instantiateForNew THEN
            r.declaredAsVariable := TRUE;
        END;
    END;
END;

PROCEDURE Record.codeForNew(cx: Context.Type): STRING;
BEGIN
    IF hasParameterizedConstructor(SELF) THEN
        Errors.raise("cannot use procedure NEW for '" + SELF.name + "' because it has constructor with parameters, use operator NEW instead");
    END;
    RETURN SUPER(cx);
END;

PROCEDURE Record.initializer(cx: Context.Type): STRING;
BEGIN
    ensureCanBeInstantiated(cx, SELF(POINTER), instantiateForNew);
    RETURN SUPER(cx);
END;

PROCEDURE Record.findSymbol(id: STRING): Types.PField;
BEGIN
    result <- findMethodDeclaration(SELF(POINTER), id);
    IF result = NIL THEN
        result := SUPER(id);
    END;
    RETURN result;
END;

PROCEDURE Record.addField(f: Types.PField);
BEGIN
    id <- f.id();
    IF findMethodDeclaration(SELF(POINTER), id) # NIL THEN
        Errors.raise(
            "cannot declare field, record already has method '" + id +"'");
    END;

    type <- f.type();
    IF (type IS PRecord) 
        & (type.customConstructor # NIL) 
        & (LEN(type.customConstructor.args()) # 0) THEN
        SELF.customInitedfields.add(id);
    END;
    SELF.fieldsInitOrder.add(id);

    SUPER(f);
END;

PROCEDURE Record.addMethod(methodId: Context.PIdentdefInfo; type: Types.PProcedure);
VAR
    msg: STRING;
BEGIN
    id <- methodId.id();
    existingField <- SELF.findSymbol(id);
    IF existingField # NIL THEN
        IF existingField.type()^ IS EberonTypes.MethodType THEN
            msg := "cannot declare a new method '" 
                 + id 
                 + "': method already was declared";
        ELSE
            msg := "cannot declare method, record already has field '" + id + "'";
        END;
        Errors.raise(msg);
    END;

    JsMap.put(SELF.declaredMethods, id, NEW RecordFieldAsMethod(methodId, type));
    IF ~methodId.exported() THEN
        SELF.nonExportedMethods.add(id);
    END;
END;

PROCEDURE Record.defineMethod(methodId: Context.PIdentdefInfo; type: EberonTypes.PMethodType);
VAR 
    existingType: Types.PDefinedProcedure;
BEGIN
    id <- methodId.id();
    IF SELF.definedMethods.indexOf(id) # -1 THEN
        Errors.raise("method '" + SELF.name + "." + id + "' already defined");
    END;

    existingField <- SELF.findSymbol(id);
    IF existingField # NIL THEN
        t <- existingField.type();
        IF t^ IS EberonTypes.MethodType THEN
            existingType := t.procType();
        END;
    END;
    IF existingType = NIL THEN
        Errors.raise("'" + SELF.name + "' has no declaration for method '" + id + "'");
    END;

    addType <- type.procType();
    IF ~Cast.areProceduresMatch(existingType, addType) THEN
        Errors.raise("overridden method '" + id + "' signature mismatch: should be '"
                   + existingType.description() + "', got '" 
                   + addType.description() + "'");
    END;
    
    SELF.definedMethods.add(id);
END;

PROCEDURE Record.requireNewOnly();
BEGIN
    SELF.createByNewOnly := TRUE;
END;

PROCEDURE Record.setBaseConstructorCallCode(code: STRING);
BEGIN
    SELF.baseConstructorCallCode := code;
END;

PROCEDURE Record.setFieldInitializationCode(field: STRING; code: STRING);
BEGIN
    index <- SELF.fieldsInitOrder.indexOf(field);
    IF index < SELF.lastFieldInit THEN
        Errors.raise("field '" + field + "' must be initialized before '" 
                   + SELF.fieldsInitOrder[SELF.lastFieldInit] + "'");
    ELSE
        SELF.lastFieldInit := index;
    END;
    JsMap.putString(SELF.fieldsInit, field, code);
END;

PROCEDURE Record.setRecordInitializationCode(baseConstructorCallCode: STRING);
BEGIN
    SELF.baseConstructorCallCode := baseConstructorCallCode;
END;

PROCEDURE Record.declareConstructor(type: Types.PDefinedProcedure; exported: BOOLEAN);
BEGIN
    IF SELF.customConstructor # NIL THEN
        Errors.raise("constructor '" + SELF.name + "' already declared");
    END;
    IF type.result() # NIL THEN
        Errors.raise("constructor '" + SELF.name + "' cannot have result type specified");
    END;

    SELF.customConstructor := type;
    SELF.customConstructorExported := exported;
END;

PROCEDURE Record.defineConstructor(type: Types.PDefinedProcedure);
BEGIN
    IF SELF.customConstructor = NIL THEN
        Errors.raise("constructor was not declared for '" + SELF.name +"'");
    END;
    IF SELF.customConstructorDefined THEN
        Errors.raise("constructor already defined for '" + SELF.name +"'");
    END;
    IF ~Cast.areProceduresMatch(SELF.customConstructor, type) THEN
        Errors.raise("constructor '" + SELF.name + "' signature mismatch: declared as '"
                   + SELF.customConstructor.description() + "' but defined as '" 
                   + type.description() + "'");
    END;
    SELF.customConstructorDefined := TRUE;
END;

PROCEDURE collectAbstractMethods(r: Record);
VAR
    methods: ARRAY * OF STRING;
BEGIN
    selfMethods <- JsMap.keys(r.declaredMethods);
    baseType <- r.base(PRecord);
    IF baseType # NIL THEN
        JS.do("methods = baseType.abstractMethods.concat(selfMethods);");
    ELSE
        methods := selfMethods;
    END;

    FOR i <- 0 TO LEN(methods) - 1 DO
        m <- methods[i];
        IF r.definedMethods.indexOf(m) = -1 THEN
            r.abstractMethods.add(m);
        END;
    END;
END;

PROCEDURE checkIfFieldsInited(r: Record);
VAR
    fieldsWereNotInited: ARRAY * OF STRING;
BEGIN
    FOR i <- 0 TO LEN(r.customInitedfields) - 1 DO
        f <- r.customInitedfields[i];
        IF ~JsMap.hasString(r.fieldsInit, f) THEN
            fieldsWereNotInited.add(f);
        END;
    END;

    IF LEN(fieldsWereNotInited) # 0 THEN
        Errors.raise("constructor '" + r.name + "' must initialize fields: " 
                   + String.join(fieldsWereNotInited, ", "));
    END;
END;

PROCEDURE Record.finalize();
BEGIN
    SELF.finalized := TRUE;

    IF (SELF.customConstructor # NIL) & ~SELF.customConstructorDefined THEN
        Errors.raise("constructor was declared for '" + SELF.name + "' but was not defined");
    END;

    collectAbstractMethods(SELF);
    IF SELF.instantiated THEN
        ensureNonAbstract(SELF(POINTER));
    END;
    
    IF SELF.declaredAsVariable THEN
        ensureVariableCanBeDeclared(SELF(POINTER));
    END;
    
    ensureMethodDefinitions(SELF(POINTER), SELF.lazyDefinitions);

    FOR i <- 0 TO LEN(SELF.nonExportedMethods) - 1 DO
        JsMap.erase(SELF.declaredMethods, SELF.nonExportedMethods[i]);
    END;
    SELF.nonExportedMethods.clear();

    checkIfFieldsInited(SELF);

    SUPER();
END;

PROCEDURE RecordField.asVar(isReadOnly: BOOLEAN; cx: Context.Type): Types.PId;
BEGIN
    actualReadOnly <- isReadOnly;
    IF ~actualReadOnly & (LEN(cx.qualifyScope(Types.recordScope(SELF.record^))) # 0) THEN
        actualReadOnly := SELF.identdef()(EberonContext.PIdentdefInfo).isReadOnly();
    END;
    RETURN SUPER(actualReadOnly, cx); 
END;

PROCEDURE Record.Record(name: STRING; cons: STRING; scope: ScopeBase.PType)
    | SUPER(name, cons, scope),
      declaredMethods(JsMap.make()),
      lazyDefinitions(JsMap.make()),
      fieldsInit(JsMap.makeStrings()),
      lastFieldInit(-1);
END;

PROCEDURE genFieldInitCode(key: STRING; value: Object.PType; VAR closure: Object.Type);
    PROCEDURE do(f: Types.PField; VAR closure: GenFieldInitCodeClosure);
    VAR
        code: STRING;
        result: STRING;
    BEGIN
        type <- f.type()(Types.PStorageType);
        IF JsMap.findString(closure.record.fieldsInit, key, code) THEN
            result := code;
        ELSE
            result := "this." + Types.mangleField(key, type) 
                    + " = " + type.initializer(closure.cx^);
        END;
        closure.code := closure.code + result + ";" + Stream.kCR;
    END;
BEGIN
    do(value(Types.PField), closure(GenFieldInitCodeClosure));
END;

PROCEDURE fieldsInitializationCode*(r: PRecord; cx: Context.PType): STRING;
VAR
    closure: GenFieldInitCodeClosure;
BEGIN
    closure.cx := cx;
    closure.record := r;
    JsMap.forEach(Types.recordOwnFields(r^), genFieldInitCode, closure);
    RETURN closure.code;
END;

PROCEDURE RecordField.RecordField(identdef: Context.PIdentdefInfo; type: Types.PType; record: PRecord)
    | SUPER(identdef, type);
BEGIN
    SELF.record := record;
END;

END EberonRecord.