MODULE EberonTypes;
IMPORT Code, Context, JsArray, LanguageContext, Procedure, Types;

TYPE
    CallGenerator = PROCEDURE(cx: LanguageContext.PType; type: Types.DefinedProcedure): Procedure.PCallGenerator;

    MethodType* = RECORD(Procedure.Std)
        PROCEDURE procType(): Types.PProcedure;
        PROCEDURE args(): JsArray.Type;
        PROCEDURE result(): Types.PType;
        PROCEDURE procDescription(): STRING;

        type: Types.PDefinedProcedure;
        call: CallGenerator
    END;
    PMethodType = POINTER TO MethodType;

    MethodVariable* = RECORD(Types.Variable)
        mType: Types.PType
    END;

    DynamicArray* = RECORD(Types.Array)
    END;
    PDynamicArray* = POINTER TO DynamicArray;

    DynamicArrayMethodField = RECORD(Types.Field)
    END;
    (*
    DynamicArrayAddCall = RECORD(Procedure.StdCall)
    END;
    *)
    DynamicArrayAddCallGenerator = RECORD(Procedure.CallGenerator)
        arg: Code.PExpression
    END;

    DynamicArrayMethod = RECORD(Procedure.Std)
    END;
VAR
    dynamicArrayAdd: POINTER TO DynamicArrayMethodField;
    dynamicArrayAddMethod: POINTER TO DynamicArrayMethod;

PROCEDURE arrayDimensionDescription*(VAR a: Types.Array): STRING;
VAR
    result: STRING;
BEGIN
    IF a IS DynamicArray THEN
        result := "*";
    ELSE
        result := Types.arrayDimensionDescription(a);
    END;
    RETURN result
END arrayDimensionDescription;

PROCEDURE DynamicArray.initializer(cx: Context.Type; forNew: BOOLEAN): STRING;
    RETURN "[]"
END DynamicArray.initializer;

PROCEDURE DynamicArray.description(): STRING;
    RETURN Types.arrayDescription(SELF, arrayDimensionDescription)
END DynamicArray.description;

PROCEDURE DynamicArray.denote(id: STRING): Types.PField;
BEGIN
    RETURN dynamicArrayAdd
END DynamicArray.denote;

PROCEDURE MethodType.designatorCode(id: STRING): STRING;
    RETURN id
END MethodType.designatorCode;

PROCEDURE MethodType.procType(): Types.PProcedure;
    RETURN SELF.type
END MethodType.procType;

PROCEDURE MethodType.args(): JsArray.Type;
    RETURN SELF.type.args()
END MethodType.args;

PROCEDURE MethodType.result(): Types.PType;
    RETURN SELF.type.result()
END MethodType.result;

PROCEDURE MethodType.description(): STRING;
    RETURN "method " + SELF.name
END MethodType.description;

PROCEDURE MethodType.procDescription(): STRING;
    RETURN SELF.type.description()
END MethodType.procDescription;

PROCEDURE MethodType.callGenerator(cx: LanguageContext.PType): Procedure.PCallGenerator;
    RETURN SELF.call(cx, SELF.type^)
END MethodType.callGenerator;

PROCEDURE makeMethodType*(id: STRING; t: Types.PDefinedProcedure; call: CallGenerator): PMethodType;
VAR
    result: PMethodType;
BEGIN
    NEW(result);
    result.name := id;
    result.type := t;
    result.call := call;
    RETURN result
END makeMethodType;

PROCEDURE MethodVariable.type(): Types.PType;
    RETURN SELF.mType
END MethodVariable.type;

PROCEDURE MethodVariable.isReadOnly(): BOOLEAN;
    RETURN TRUE
END MethodVariable.isReadOnly;

PROCEDURE MethodVariable.idType(): STRING;
    RETURN "method"
END MethodVariable.idType;

PROCEDURE MethodVariable.isReference(): BOOLEAN;
    RETURN FALSE
END MethodVariable.isReference;

PROCEDURE makeMethodVariable*(type: Types.PType): Types.PVariable;
VAR
    result: POINTER TO MethodVariable;
BEGIN
    NEW(result);
    result.mType := type;
    RETURN result
END makeMethodVariable;

PROCEDURE makeDynamicArray*(elementsType: Types.PType): PDynamicArray;
VAR
    result: PDynamicArray;
BEGIN
    NEW(result);
    Types.initArray(elementsType, result^);
    RETURN result
END makeDynamicArray;

PROCEDURE DynamicArrayMethodField.id(): STRING;
    RETURN "add"
END DynamicArrayMethodField.id;

PROCEDURE DynamicArrayMethodField.exported(): BOOLEAN;
    RETURN FALSE
END DynamicArrayMethodField.exported;

PROCEDURE DynamicArrayMethodField.type(): Types.PType;
    RETURN dynamicArrayAddMethod
END DynamicArrayMethodField.type;

PROCEDURE DynamicArrayMethodField.asVar(): Types.PId;
    RETURN makeMethodVariable(dynamicArrayAddMethod)
END DynamicArrayMethodField.asVar;
(*
PROCEDURE DynamicArrayAddCall.make(args: JsArray.Type; cx: LanguageContext.Type): Code.PExpression;
BEGIN
    arg <- Procedure.checkSingleArgument(args, SELF, cx.types);
    RETURN Code.makeSimpleExpression(
            SELF.varId + ".push(" + arg.code() + ")",
            NIL)
END DynamicArrayAddCall.make;
*)
PROCEDURE DynamicArrayAddCallGenerator.handleArgument(e: Code.PExpression);
BEGIN
    SELF.arg := e;
END DynamicArrayAddCallGenerator.handleArgument;

PROCEDURE DynamicArrayAddCallGenerator.end(): Code.PExpression;
    RETURN Code.makeSimpleExpression(
            "(" + SELF.arg.code() + ")",
            NIL)
END DynamicArrayAddCallGenerator.end;

PROCEDURE DynamicArrayMethod.designatorCode(id: STRING): STRING;
    RETURN "push"
END DynamicArrayMethod.designatorCode;

PROCEDURE DynamicArrayMethod.callGenerator(cx: LanguageContext.PType): Procedure.PCallGenerator;
VAR
    result: POINTER TO DynamicArrayAddCallGenerator;
BEGIN
    NEW(result);
    RETURN result
END DynamicArrayMethod.callGenerator;

BEGIN
    NEW(dynamicArrayAddMethod);
    NEW(dynamicArrayAdd);
END EberonTypes.