MODULE EberonArray;
IMPORT Code, Context, EberonTypes, Errors, LanguageContext, Procedure, Types;
CONST
    methodNameIndexOf = "indexOf";
TYPE
    Method* = RECORD(Procedure.Std)
    END;
    PMethod* = POINTER TO Method;

    MethodField* = RECORD(Types.Field)
        PROCEDURE MethodField*(method: PMethod);

        method: PMethod
    END;

    MethodIndexOf = RECORD(Method)
        PROCEDURE MethodIndexOf(elementsType: Types.PType);

        elementsType: Types.PType
    END;

    MethodCallIndexOf = RECORD(Procedure.StdCall)
    END;

    StaticArray* = RECORD(Types.StaticArray)
    END;

    OpenArray* = RECORD(Types.OpenArray)
    END;

PROCEDURE Method.description(): STRING;
    RETURN "array method '" + SELF.name + "'"
END Method.description;

PROCEDURE MethodField.id(): STRING;
    RETURN SELF.method.name
END MethodField.id;

PROCEDURE MethodField.exported(): BOOLEAN;
    RETURN FALSE
END MethodField.exported;

PROCEDURE MethodField.type(): Types.PType;
    RETURN SELF.method
END MethodField.type;

PROCEDURE MethodField.asVar(isReadOnly: BOOLEAN; cx: Context.Type): Types.PId;
    RETURN EberonTypes.makeMethod(SELF.method)
END MethodField.asVar;

PROCEDURE MethodIndexOf.MethodIndexOf(elementsType: Types.PType)
    | SUPER(methodNameIndexOf, NIL),
      elementsType(elementsType);
BEGIN
END;

PROCEDURE MethodIndexOf.designatorCode(id: STRING): STRING;
    RETURN "indexOf"
END MethodIndexOf.designatorCode;

PROCEDURE MethodIndexOf.callGenerator(cx: LanguageContext.PType): Procedure.PCallGenerator;
BEGIN
    call <- NEW MethodCallIndexOf();
    a <- NEW Types.ProcedureArgument(SELF.elementsType, FALSE);
    call.args.add(a);
    RETURN Procedure.makeCallGenerator(call, cx)
END MethodIndexOf.callGenerator;

PROCEDURE MethodCallIndexOf.make(args: ARRAY OF Code.PExpression; cx: LanguageContext.PType): Code.PExpression;
BEGIN
    argCode <- Procedure.makeArgumentsCode(cx);
    argType <- Procedure.checkSingleArgument(args, SELF, cx.types, argCode).type();
    RETURN Code.makeSimpleExpression("(" + argCode.result() + ")", Types.basic.integer)
END MethodCallIndexOf.make;

PROCEDURE denoteMethod*(id: STRING; elementsType: Types.PType): PMethod;
VAR
    result: PMethod;
BEGIN
    IF id = methodNameIndexOf THEN
        result := NEW MethodIndexOf(elementsType);
    END;
    RETURN result
END denoteMethod;

PROCEDURE MethodField.MethodField(method: PMethod)
    | method(method);
END;

PROCEDURE denote(id: STRING; a: Types.Array): Types.PField;
VAR
    result: Types.PField;
BEGIN
    IF id = methodNameIndexOf THEN
        IF (a.elementsType IS Types.PRecord) OR (a.elementsType IS Types.PArray) THEN
            Errors.raise("'" + methodNameIndexOf + "' is not defined for array of '" + a.elementsType.description() + "'");
        END;
        result := NEW MethodField(NEW MethodIndexOf(a.elementsType));
    END;
    RETURN result
END denote;

PROCEDURE StaticArray.denote(id: STRING): Types.PField;
BEGIN
    result <- denote(id, SELF);
    IF result = NIL THEN
        result := SUPER(id);
    END;
    RETURN result
END StaticArray.denote;

PROCEDURE OpenArray.denote(id: STRING): Types.PField;
BEGIN
    result <- denote(id, SELF);
    IF result = NIL THEN
        result := SUPER(id);
    END;
    RETURN result
END OpenArray.denote;

END EberonArray.
