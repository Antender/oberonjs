MODULE EberonContextExpression;
IMPORT
    Cast,
    Context, ContextExpression, ContextHierarchy, 
    EberonContextDesignator, 
    EberonMap, EberonOperator, EberonString, EberonTypePromotion, 
    Errors, Expression, ExpressionTree, LanguageContext,
    JS,
    Object, Record, Types;
TYPE
    PNode = POINTER TO Node;

    ExpressionNode* = RECORD(ContextExpression.ExpressionHandler)
        PROCEDURE ExpressionNode(parent: ContextHierarchy.PNode);

        currentNode: PNode;
        typePromotion: EberonTypePromotion.PType;
        condition, first, second: Expression.PType;
    END;
    PExpressionNode = POINTER TO ExpressionNode;

    RelationExpression* = RECORD(ContextExpression.ExpressionNode)
        PROCEDURE RelationExpression(parent: PExpressionNode);
    END;

    SimpleExpression* = RECORD(ContextExpression.SimpleExpression)
    END;

    Term* = RECORD(ContextExpression.Term)
    END;
    PTerm = POINTER TO Term;

    Factor* = RECORD(ContextExpression.Factor)
    END;

    Ops = RECORD(ExpressionTree.Ops)
    END;

    PSimpleList = POINTER TO SimpleList;

    TermList = RECORD(ExpressionTree.TermList)
        PROCEDURE TermList(parentSimple: PSimpleList);

        parentSimple: PSimpleList;

        typePromotion: EberonTypePromotion.PCombined;
        currentPromotion: EberonTypePromotion.PMaybe;
        andHandled: BOOLEAN;
    END;
    PTermList = POINTER TO TermList;

    SimpleList = RECORD(ExpressionTree.SimpleList)
        PROCEDURE SimpleList(parentTerm: PTermList);

        parentTerm: PTermList;

        typePromotion: EberonTypePromotion.PCombined;
        currentPromotion: EberonTypePromotion.PMaybe;
        orHandled: BOOLEAN;
    END;

    Node = RECORD(ExpressionTree.Node)
        PROCEDURE Node(parentTerm: PTermList);

        parentTerm: PTermList;
        combinedTypePromotion: EberonTypePromotion.PCombined;
        varTypePromotion: EberonTypePromotion.PType;
    END;

    ETFactor = RECORD(ExpressionTree.Factor)
        PROCEDURE ETFactor(termList: PTermList);

        termList: PTermList;
    END;

VAR
    setTermTypePromotion: PROCEDURE(VAR term: TermList): EberonTypePromotion.PMaybe;
    globalOps: POINTER TO Ops;

PROCEDURE hierarchyDepth(t: Record.Type): INTEGER;
BEGIN
    result <- 0;
    base <- t.base;
    WHILE base # NIL DO
        INC(result);
        base := base.base;
    END;
    RETURN result;
END;

PROCEDURE getNthBase(t: Record.PType; n: INTEGER): Record.PType;
BEGIN
    result <- t;
    i <- n;
    WHILE i # 0 DO
        result := result.base;
        DEC(i);
    END;
    RETURN result;
END;

PROCEDURE findCommonBase(t1, t2: Record.PType): Record.PType;
VAR
    result: Record.PType;
BEGIN
    depth1 <- hierarchyDepth(t1^);
    depth2 <- hierarchyDepth(t2^);
    commonBase1 <- t1;
    commonBase2 <- t2;
    IF depth1 > depth2 THEN
        commonBase1 := getNthBase(commonBase1, depth1 - depth2);
    ELSE
        commonBase2 := getNthBase(commonBase2, depth2 - depth1);
    END;

    WHILE commonBase1 # commonBase2 DO
        commonBase1 := commonBase1.base;
        commonBase2 := commonBase2.base;
    END;

    RETURN commonBase1;
END;

PROCEDURE parentTerm(VAR maybeFactor: ContextHierarchy.Node): PTermList;
    RETURN maybeFactor IS ContextExpression.Factor 
        ? maybeFactor.factor^(ETFactor).termList
        : NIL;
END;

PROCEDURE ExpressionNode.ExpressionNode(parent: ContextHierarchy.PNode)
    | SUPER(parent),
      currentNode(NEW Node(parentTerm(parent^)));
END;

PROCEDURE processTypePromotion(node: Node): EberonTypePromotion.PType;
BEGIN
    typePromotion <- node.combinedTypePromotion;
    RETURN typePromotion # NIL ? typePromotion 
                               : node.varTypePromotion;
END;

PROCEDURE ExpressionNode.handleExpression(e: Expression.PType);
BEGIN
    IF SELF.condition = NIL THEN
        SELF.condition := e;
        SELF.typePromotion := processTypePromotion(SELF.currentNode^);
    ELSIF SELF.first = NIL THEN
        SELF.first := e;
    ELSE
        SELF.second := e;
    END;

    SELF.currentNode := NEW Node(SELF.currentNode.parentTerm);
END;

PROCEDURE ExpressionNode.handleLiteral(s: STRING);
BEGIN
    parentTerm <- SELF.currentNode.parentTerm;
    IF parentTerm # NIL THEN
        parentTerm.typePromotion := NIL;
    END;

    IF SELF.typePromotion # NIL THEN
        IF s = "?" THEN
            SELF.typePromotion.and();
        ELSE
            SELF.typePromotion.reset();
            SELF.typePromotion.or();
        END;
    END;
END;

PROCEDURE ExpressionNode.endParse(): BOOLEAN;
VAR
    resultType: Types.PType;
    op: LanguageContext.PCastOp;
BEGIN
    result <- SELF.first;
    IF result = NIL THEN
        result := SELF.condition;

        IF (SELF.typePromotion # NIL) & (SELF.currentNode.parentTerm = NIL) THEN
            msg <- EberonContextDesignator.TransferPromotedTypesMsg(SELF.typePromotion);
            void <- SELF.parent().handleMessage(msg);
        END;
    ELSE
        firstType <- SELF.first.type();
        secondType <- SELF.second.type();
        IF (firstType IS Record.PType) & (secondType IS Record.PType) THEN
            resultType := findCommonBase(firstType, secondType);
        ELSIF (firstType IS Record.PPointer) & (secondType IS Record.PPointer) THEN
            resultType := EberonContextDesignator.makePointer(findCommonBase(Record.pointerBase(firstType^), Record.pointerBase(secondType^)));
        ELSIF (firstType = Types.nil) & (secondType IS Record.PPointer) THEN
            resultType := secondType;
        ELSIF (secondType = Types.nil) & (firstType IS Record.PPointer) THEN
            resultType := firstType;
        END;

        IF resultType = NIL THEN 
            IF SELF.root().language().types.implicitCast(firstType, secondType, FALSE, op) # Cast.errNo THEN
                Errors.raise("incompatible types in ternary operator: '" 
                             + firstType.description() + "' and '" + secondType.description() + "'");
            END;
            resultType := firstType;
        END;

        result := Expression.makeSimple(SELF.condition.code() + " ? " 
                                        + SELF.first.code() + " : "
                                        + SELF.second.code(),
                                        resultType);
    END;
    SELF.parent()(ContextExpression.PExpressionHandler).handleExpression(result);
    RETURN TRUE;
END;

PROCEDURE RelationExpression.RelationExpression(parent: PExpressionNode)
    | SUPER(parent, parent.currentNode);
END;

PROCEDURE Ops.in(left, right: Types.PType; cx: ContextHierarchy.Node): ExpressionTree.BinaryOperatorCx;
VAR
    result: ExpressionTree.BinaryOperatorCx;
BEGIN
    IF right IS EberonMap.PType THEN
        EberonContextDesignator.checkMapKeyType(left);
        result := EberonOperator.inMap;            
    ELSE
        result := SUPER(left, right, cx);
    END;
    RETURN result;
END;

PROCEDURE setSimpleExpressionTypePromotion(VAR e: SimpleList): EberonTypePromotion.PMaybe;
BEGIN
    IF e.currentPromotion = NIL THEN
        IF e.parentTerm # NIL THEN
            p <- setTermTypePromotion(e.parentTerm^);
            IF p # NIL THEN
                e.typePromotion := p.makeOr();
            END;
        ELSE
            e.typePromotion := NEW EberonTypePromotion.Or(FALSE);
        END;

        IF e.typePromotion # NIL THEN
            IF e.orHandled THEN
                unused <- e.typePromotion.next();
            END;
            e.currentPromotion := e.typePromotion.next();
        END;
    END;
    RETURN e.currentPromotion;
END;

PROCEDURE setTermTypePromotionProc(VAR term: TermList): EberonTypePromotion.PMaybe;
BEGIN
    IF term.currentPromotion = NIL THEN
        p <- setSimpleExpressionTypePromotion(term.parentSimple^);
        IF p # NIL THEN
            term.typePromotion := p.makeAnd();
        END;

        IF term.typePromotion # NIL THEN
            IF term.andHandled THEN
                unused <- term.typePromotion.next();
            END;
            term.currentPromotion := term.typePromotion.next();
        END;
    END;
    RETURN term.currentPromotion;
END;

PROCEDURE TermList.addOp(op: STRING);
BEGIN
    SUPER(op);

    IF SELF.typePromotion # NIL THEN
        SELF.currentPromotion := SELF.typePromotion.next();
    ELSE
        SELF.andHandled := TRUE;
    END;
END;

PROCEDURE Ops.plus(type: Types.PType): ExpressionTree.BinaryOperator;
    RETURN (type = EberonString.string) OR (type IS Types.PString) 
        ? EberonOperator.addStr
        : SUPER(type);
END;

PROCEDURE Ops.plusExpect(): STRING;
    RETURN "numeric type or SET or STRING";
END;

PROCEDURE Ops.eq(type: Types.PType): ExpressionTree.BinaryOperatorCx;
    RETURN type = EberonString.string
        ? EberonOperator.equalStr
        : SUPER(type);
END;

PROCEDURE Ops.notEq(type: Types.PType): ExpressionTree.BinaryOperatorCx;
    RETURN type = EberonString.string
        ? EberonOperator.notEqualStr
        : SUPER(type);
END;

PROCEDURE Ops.less(type: Types.PType): ExpressionTree.BinaryOperatorCx;
    RETURN type = EberonString.string
        ? EberonOperator.lessStr
        : SUPER(type);
END;

PROCEDURE Ops.greater(type: Types.PType): ExpressionTree.BinaryOperatorCx;
    RETURN type = EberonString.string
        ? EberonOperator.greaterStr
        : SUPER(type);
END;

PROCEDURE Ops.lessEq(type: Types.PType): ExpressionTree.BinaryOperatorCx;
    RETURN type = EberonString.string
        ? EberonOperator.lessEqualStr
        : SUPER(type);
END;

PROCEDURE Ops.greaterEq(type: Types.PType): ExpressionTree.BinaryOperatorCx;
    RETURN type = EberonString.string
        ? EberonOperator.greaterEqualStr
        : SUPER(type);
END;

PROCEDURE Ops.coalesceType(leftType, rightType: Types.PType): Types.PType;
    RETURN    (((leftType = EberonString.string) & (rightType IS Types.PString))
           OR ((rightType = EberonString.string) & (leftType IS Types.PString)))
        ? EberonString.string
        : SUPER(leftType, rightType);
END;

PROCEDURE Node.Node(parentTerm: PTermList)
    | SUPER(globalOps),
      parentTerm(parentTerm);
END;

PROCEDURE Node.makeSimple(): ExpressionTree.PSimpleList;
    RETURN NEW SimpleList(SELF.parentTerm);
END;

PROCEDURE Node.addSimple(s: ExpressionTree.PSimpleList);
BEGIN
    SELF.combinedTypePromotion := s(PSimpleList).typePromotion;

    IF (SELF.left # NIL) & (SELF.right.op = "IS") THEN
        d <- SELF.left.term.factor.expression.designator();
        IF d # NIL THEN
            v <- d.info();
            IF v IS EberonTypePromotion.PVariable THEN
                type <- ExpressionTree.unwrapType(s.term.factor.expression.designator().info());
                IF SELF.parentTerm = NIL THEN
                    SELF.varTypePromotion := NEW EberonTypePromotion.ForVariable(v, type, FALSE);
                ELSE
                    p <- setTermTypePromotion(SELF.parentTerm^);
                    p.promote(v, type);
                END;
            END;
        END;
    END;

    SUPER(s);
END;

PROCEDURE Node.addOp(op: STRING);
BEGIN
    IF SELF.combinedTypePromotion # NIL THEN
        SELF.combinedTypePromotion.clear();
    END;

    SUPER(op);
END;

PROCEDURE SimpleList.SimpleList(parentTerm: PTermList)
    | parentTerm(parentTerm);
END;

PROCEDURE SimpleList.makeTerm(): ExpressionTree.PTermList;
    RETURN NEW TermList(SELF(POINTER));
END;

PROCEDURE SimpleList.addOp(op: STRING);
BEGIN
    SUPER(op);

    IF SELF.typePromotion # NIL THEN
        SELF.currentPromotion := SELF.typePromotion.next();
    ELSE
        SELF.orHandled := TRUE;
    END;
END;

PROCEDURE TermList.TermList(parentSimple: PSimpleList)
    | parentSimple(parentSimple);
END;

PROCEDURE TermList.makeFactor(): ExpressionTree.PFactor;
    RETURN NEW ETFactor(SELF(POINTER));
END;

PROCEDURE ETFactor.ETFactor(termList: PTermList)
    | termList(termList);
END;

PROCEDURE ETFactor.logicalNot();
BEGIN
    SUPER();

    p <- setTermTypePromotion(SELF.termList^);
    IF p # NIL THEN
        p.invert()
    END;
END;

BEGIN
    (*resolve recursive calls*)
    setTermTypePromotion := setTermTypePromotionProc;
    
    NEW(globalOps);
END EberonContextExpression.