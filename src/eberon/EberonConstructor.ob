MODULE EberonConstructor;
IMPORT Cast, Code, EberonCast, EberonRecord, Errors, LanguageContext, Operator, Procedure, Stream, Types;
TYPE
    ConstructorCall = RECORD(Procedure.StdCall)
        recordType: EberonRecord.PRecord;
        resultType: Types.PType;
    END;
    PConstructorCall = POINTER TO ConstructorCall;

    BaseConstructorCall = RECORD(ConstructorCall)
    END;

    RecordInitCall = RECORD(ConstructorCall)
        field: STRING;
    END;

    NonRecordInitCall = RECORD(Procedure.CallGenerator)
        cx: LanguageContext.PType;
        type: Types.PStorageType;
        field: STRING;
        code: STRING;
    END;

PROCEDURE checkArgs(call: ConstructorCall; args: ARRAY OF Code.PExpression; cx: LanguageContext.PType): STRING;
BEGIN
    argCode <- Procedure.makeArgumentsCode(cx);
    Procedure.processArguments(args, call.args, argCode, cx.types);
    RETURN argCode.result();
END;

PROCEDURE ConstructorCall.make(args: ARRAY OF Code.PExpression; cx: LanguageContext.PType): Code.PExpression;
BEGIN
    argCode <- checkArgs(SELF, args, cx);
    RETURN Code.makeSimpleExpression(Types.recordInitializer(cx^, SELF.recordType^, argCode), SELF.resultType);
END;

PROCEDURE BaseConstructorCall.make(args: ARRAY OF Code.PExpression; cx: LanguageContext.PType): Code.PExpression;
BEGIN
    argCode <- checkArgs(SELF, args, cx);
    code <- cx.qualifyScope(SELF.recordType.scope) + SELF.recordType.cons + ".call(this, " + argCode + ");" + Stream.kCR;
    RETURN Code.makeSimpleExpression(code, NIL);
END;

PROCEDURE fieldInitLval(field: STRING; type: Types.PStorageType): STRING;
    RETURN "this." + Types.mangleField(field, type);
END;

PROCEDURE RecordInitCall.make(args: ARRAY OF Code.PExpression; cx: LanguageContext.PType): Code.PExpression;
BEGIN
    e <- SUPER(args, cx);
    t <- e.type()(Types.PStorageType);
    RETURN Code.makeSimpleExpression(fieldInitLval(SELF.field, t) + " = " + e.code(), t);
END;

PROCEDURE makeCallGenerator(
    recordType: EberonRecord.PRecord; 
    resultType: Types.PType;
    cx: LanguageContext.PType;
    call: PConstructorCall
    ): Procedure.PCallGenerator;
BEGIN
    call.recordType := recordType; 
    call.resultType := resultType;
    cons <- EberonRecord.constructor(recordType^);
    IF cons # NIL THEN
        call.args := cons.args();
    END;
    RETURN Procedure.makeCallGenerator(call, cx)
END;

PROCEDURE raiseSingleArgumentException(c: NonRecordInitCall);
BEGIN
    Errors.raise("single argument expected to initialize field '" + c.field + "'");
END;

PROCEDURE NonRecordInitCall.handleArgument(e: Code.PExpression);
VAR
    op: Cast.PCastOp;
BEGIN
    IF LEN(SELF.code) # 0 THEN
        raiseSingleArgumentException(SELF);
    END;

    IF SELF.cx.types.implicitCast(e.type(), SELF.type, FALSE, Operator.castOperations, op)
        # Cast.errNo THEN
            Errors.raise("type mismatch: field '" + SELF.field + "' is '" + SELF.type.description()
                         + "' and cannot be initialized using '" + e.type().description() + "' expression");
    END;
    lval <- fieldInitLval(SELF.field, SELF.type);
    SELF.code := lval + " = " + op.clone(SELF.cx.rtl, e);
END;
        
PROCEDURE NonRecordInitCall.end(): Code.PExpression;
BEGIN
    IF LEN(SELF.code) = 0 THEN
        raiseSingleArgumentException(SELF);
    END;
    RETURN Code.makeSimpleExpression(SELF.code, NIL);
END;

PROCEDURE makeConstructorCall*(
    typeId: Types.PTypeId;
    cx: LanguageContext.PType;
    forNew: BOOLEAN
    ): Procedure.PCallGenerator;
BEGIN
    call <- NEW ConstructorCall();
    resultType <- typeId.type();
    recordType <- resultType(EberonRecord.PRecord); 
    
    instType <- EberonRecord.instantiateForVar;
    IF forNew THEN
        instType := EberonRecord.instantiateForNew;
    END;
    
    EberonRecord.ensureCanBeInstantiated(cx^, recordType, instType);
    IF forNew THEN
        resultType := NEW Types.Pointer("", typeId);
    END;
    RETURN makeCallGenerator(recordType, resultType, cx, call);
END;

PROCEDURE makeFieldInitCall*(
    type: Types.PStorageType; 
    cx: LanguageContext.PType;
    field: STRING
    ): Procedure.PCallGenerator;
VAR
    result: Procedure.PCallGenerator;

    PROCEDURE initRecord(type: EberonRecord.PRecord): Procedure.PCallGenerator;
    BEGIN
        call <- NEW RecordInitCall();
        call.field := field;
        RETURN makeCallGenerator(type, type, cx, call);
    END;

    PROCEDURE initNonRecord(): Procedure.PCallGenerator;
    BEGIN
        result <- NEW NonRecordInitCall();
        result.cx := cx;
        result.field := field;
        result.type := type;
        RETURN result;
    END;
BEGIN
    IF type IS EberonRecord.PRecord THEN
        result := initRecord(type);
    ELSE
        result := initNonRecord();
    END;
    RETURN result;
END;

PROCEDURE makeBaseConstructorCall*(
    type: EberonRecord.PRecord; 
    cx: LanguageContext.PType
    ): Procedure.PCallGenerator;
    RETURN makeCallGenerator(type, type, cx, NEW BaseConstructorCall());
END;

END EberonConstructor.