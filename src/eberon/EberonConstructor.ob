MODULE EberonConstructor;
IMPORT Code, EberonRecord, LanguageContext, Procedure, Stream, Types;
TYPE
    ConstructorCall = RECORD(Procedure.StdCall)
        recordType: EberonRecord.PRecord;
    END;
    PConstructorCall = POINTER TO ConstructorCall;

    BaseConstructorCall = RECORD(ConstructorCall)
    END;

PROCEDURE checkArgs(call: ConstructorCall; args: ARRAY OF Code.PExpression; cx: LanguageContext.PType): STRING;
BEGIN
    argCode <- Procedure.makeArgumentsCode(cx);
    Procedure.processArguments(args, call.args, argCode, cx.types);
    RETURN argCode.result();
END;

PROCEDURE ConstructorCall.make(args: ARRAY OF Code.PExpression; cx: LanguageContext.PType): Code.PExpression;
BEGIN
    argCode <- checkArgs(SELF, args, cx);
    RETURN Code.makeSimpleExpression(SELF.recordType.initializer(cx^, FALSE, argCode), SELF.recordType);
END;

PROCEDURE BaseConstructorCall.make(args: ARRAY OF Code.PExpression; cx: LanguageContext.PType): Code.PExpression;
BEGIN
    argCode <- checkArgs(SELF, args, cx);
    code <- cx.qualifyScope(SELF.recordType.scope) + SELF.recordType.cons + ".call(this, " + argCode + ");" + Stream.kCR;
    RETURN Code.makeSimpleExpression(code, NIL);
END;

PROCEDURE makeCallGenerator(
    type: EberonRecord.PRecord; 
    cx: LanguageContext.PType;
    call: PConstructorCall
    ): Procedure.PCallGenerator;
BEGIN
    Procedure.initStdCall(call);
    call.recordType := type; 
    IF type.customConstructor # NIL THEN
        call.args := type.customConstructor.args();
    END;
    RETURN Procedure.makeCallGenerator(call, cx)
END;

PROCEDURE makeConstructorCall*(
    type: EberonRecord.PRecord; 
    cx: LanguageContext.PType
    ): Procedure.PCallGenerator;
VAR
    call: PConstructorCall;
BEGIN
    NEW(call);
    RETURN makeCallGenerator(type, cx, call);
END;

PROCEDURE makeBaseConstructorCall*(
    type: EberonRecord.PRecord; 
    cx: LanguageContext.PType
    ): Procedure.PCallGenerator;
VAR
    call: POINTER TO BaseConstructorCall;
BEGIN
    NEW(call);
    RETURN makeCallGenerator(type, cx, call);
END;

END EberonConstructor.