MODULE ContextExpression;
IMPORT 
    Chars, Code, ConstValue, ContextHierarchy, Errors, Operator, String, Types;
TYPE
    ExpressionHandler = RECORD(ContextHierarchy.Node)
        PROCEDURE handleExpression(e: Code.PExpression);

        expression: Code.PExpression;
    END;

    BinaryOperator = PROCEDURE(l, r: Code.PExpression): Code.PExpression;

    Expression = RECORD(ContextHierarchy.Node)
        PROCEDURE handleSimpleExpression(e: Code.PExpression);
    END;
    PExpression = POINTER TO Expression;

    SimpleExpression* = RECORD(ContextHierarchy.Node)
        PROCEDURE SimpleExpression(parent: PExpression);

        PROCEDURE handleTerm(e: Code.PExpression);
        PROCEDURE type(): Types.PType;
        PROCEDURE setType(type: Types.PType);
        PROCEDURE handleOperator(op: BinaryOperator);

        parentExpression: PExpression;  
        mType: Types.PType;
        unaryOperator: STRING;
        binaryOperator: BinaryOperator;
        expression: Code.PExpression;
    END;
    PSimpleExpression = POINTER TO SimpleExpression;

    PFactor = POINTER TO Factor;

    Factor* = RECORD(ExpressionHandler)
        PROCEDURE Factor(parent: PFactor);

        PROCEDURE handleConst(type: Types.PType; value: ConstValue.PType; code: STRING);
        PROCEDURE handleLogicalNot();

        factorParent: PFactor;
        logicalNot: BOOLEAN;
    END;

    Term* = RECORD(ExpressionHandler)
        PROCEDURE Term(parent: PSimpleExpression);

        PROCEDURE type(): Types.PType;
        PROCEDURE handleOperator(op: BinaryOperator);

        simpleExpression: PSimpleExpression;
        operator: BinaryOperator;
    END;
    PTerm = POINTER TO Term;

    MulOperator* = RECORD(ContextHierarchy.Node)
    END;

    Const = RECORD(ContextHierarchy.Node)
        PROCEDURE Const(factor: PFactor);

        factor: PFactor;
    END;

    Integer* = RECORD(Const)
        PROCEDURE handleInt*(n: INTEGER);
    END;

    Real* = RECORD(Const)
        PROCEDURE handleReal*(r: REAL);
    END;

    Str* = RECORD(Const)
        PROCEDURE handleStr*(s: STRING);
    END;

    OpTypeCheck = RECORD
        PROCEDURE expect(): STRING;
        PROCEDURE check(t: Types.PType): BOOLEAN;
    END;

    IntOpTypeCheck = RECORD(OpTypeCheck)
    END;

    NumericOpTypeCheck = RECORD(OpTypeCheck)
    END;

    NumericOrSetOpTypeCheck = RECORD(NumericOpTypeCheck)
    END;

VAR
    intOpTypeCheck: IntOpTypeCheck;
    numericOpTypeCheck: NumericOpTypeCheck;
    numericOrSetOpTypeCheck: NumericOrSetOpTypeCheck;

PROCEDURE throwOperatorTypeMismatch*(op, expect: STRING; type: Types.PType);
BEGIN
    Errors.raise(
        "operator '" + op +
        "' type mismatch: " + expect + " expected, got '" +
        type.description() + "'");
END;

PROCEDURE assertOpType(type: Types.PType; check: OpTypeCheck; literal: STRING);
BEGIN
    IF ~check.check(type) THEN
        throwOperatorTypeMismatch(literal, check.expect(), type);
    END;
END;

PROCEDURE assertNumericOp*(type: Types.PType; literal: STRING; op, intOp: BinaryOperator): BinaryOperator;
VAR
    result: BinaryOperator;
BEGIN
    assertOpType(type, numericOpTypeCheck, literal);
    IF (intOp # NIL) & Types.isInt(type) THEN
        result := intOp;
    ELSE
        result := op;
    END;
    RETURN result;
END;

PROCEDURE assertNumericOrSetOp*(type: Types.PType; literal: STRING; op: BinaryOperator; intOp, setOp: BinaryOperator): BinaryOperator;
VAR
    result: BinaryOperator;
BEGIN
    assertOpType(type, numericOrSetOpTypeCheck, literal);
    IF Types.isInt(type) THEN
        result := intOp;
    ELSIF type = Types.basic.set THEN
        result := setOp;
    ELSE
        result := op;
    END;
    RETURN result;
END;

PROCEDURE assertIntOp(type: Types.PType; literal: STRING; op: BinaryOperator): BinaryOperator;
BEGIN
    assertOpType(type, intOpTypeCheck, literal);
    RETURN op;
END;

PROCEDURE SimpleExpression.SimpleExpression(parent: PExpression)
    | SUPER(parent),
      parentExpression(parent);
END;

PROCEDURE SimpleExpression.handleTerm(e: Code.PExpression);
VAR
    o: PROCEDURE(e: Code.PExpression): Code.PExpression;
BEGIN
    type <- e.type();
    SELF.setType(type);
    
    IF SELF.unaryOperator = "-" THEN
        IF Types.isInt(type) THEN
            o := Operator.negateInt;
        ELSIF type = Types.basic.set THEN
            o := Operator.setComplement;
        ELSIF type = Types.basic.real THEN
            o := Operator.negateReal;
        ELSE
            throwOperatorTypeMismatch(SELF.unaryOperator, numericOrSetOpTypeCheck.expect(), type);
        END;
    ELSIF SELF.unaryOperator = "+" THEN
        assertOpType(type, numericOpTypeCheck, SELF.unaryOperator);
        o := Operator.unaryPlus;
    END;

    IF o # NIL THEN
        SELF.expression := o(e);
        SELF.unaryOperator := "";
    ELSIF SELF.expression # NIL THEN
        SELF.expression := SELF.binaryOperator(SELF.expression, e);
    ELSE
        SELF.expression := e;
    END;
END;

PROCEDURE SimpleExpression.handleLiteral(s: STRING);
BEGIN
    SELF.unaryOperator := s;
END;

PROCEDURE SimpleExpression.type(): Types.PType;
    RETURN SELF.mType;
END;

PROCEDURE SimpleExpression.setType(type: Types.PType);
BEGIN
    IF (type = NIL) OR (SELF.mType = NIL) THEN
        SELF.mType := type;
    ELSE
        ContextHierarchy.checkImplicitCast(SELF.root()^, type, SELF.mType);
    END;
END;

PROCEDURE SimpleExpression.handleOperator(o: BinaryOperator);
BEGIN
    SELF.binaryOperator := o;
END;

PROCEDURE SimpleExpression.endParse();
BEGIN
    SELF.parentExpression.handleSimpleExpression(SELF.expression);
END;

PROCEDURE Factor.Factor(parent: PFactor)
    | SUPER(parent),
      factorParent(parent);
END;

PROCEDURE Factor.handleConst(type: Types.PType; value: ConstValue.PType; code: STRING);
BEGIN
    SELF.expression := Code.makeExpression(code, type, NIL, value);
END;

PROCEDURE Factor.handleLiteral(s: STRING);
BEGIN
    IF s = "NIL" THEN
        SELF.handleConst(Types.nil, NIL, "null");
    ELSIF s = "TRUE" THEN
        SELF.handleConst(Types.basic.bool, NEW ConstValue.Int(1), "true");
    ELSIF s = "FALSE" THEN
        SELF.handleConst(Types.basic.bool, NEW ConstValue.Int(0), "false");
    ELSIF s = "~" THEN
        SELF.handleLogicalNot();
    END;
END;

PROCEDURE Factor.handleLogicalNot();
BEGIN
    SELF.logicalNot := TRUE;
END;

PROCEDURE Factor.handleExpression(e: Code.PExpression);
BEGIN
    SELF.expression := e;
END;

PROCEDURE Factor.endParse();
BEGIN
    IF SELF.logicalNot THEN
        ContextHierarchy.checkTypeMatch(SELF.expression.type(), Types.basic.bool);
        SELF.expression := Operator.not(SELF.expression);
    END;
    SELF.factorParent.handleExpression(SELF.expression);
END;

PROCEDURE Term.Term(parent: PSimpleExpression)
    | SUPER(parent),
      simpleExpression(parent);
END;


PROCEDURE Term.type(): Types.PType;
VAR
    result: Types.PType;
BEGIN
    IF SELF.expression # NIL THEN
        result := SELF.expression.type();
    ELSE
        result := SELF.attributes.designator.type();
    END;
    RETURN result;
END;

PROCEDURE Term.handleOperator(op: BinaryOperator);
BEGIN
    SELF.operator := op;
END;

PROCEDURE Term.handleExpression(e: Code.PExpression);
BEGIN
    ContextHierarchy.promoteExpressionType(SELF.root()^, SELF.expression, e);
    IF SELF.operator = NIL THEN
        SELF.expression := e;
    ELSIF SELF.expression # NIL THEN
        SELF.expression := SELF.operator(SELF.expression, e);
    ELSE
        SELF.expression := SELF.operator(e, NIL);
    END;
END;

PROCEDURE Term.endParse();
VAR
    const: ConstValue.PType;
BEGIN
    e <- SELF.expression;
    IF e = NIL THEN
        d <- SELF.attributes.designator;
        info <- d.info();
        IF info IS Types.PConst THEN
            const := info.value;
        END;
        e := Code.makeExpression(d.code(), d.type(), d, const);
    END;
    SELF.simpleExpression.handleTerm(e);
END;

PROCEDURE MulOperator.handleLiteral(s: STRING);
VAR
    o: BinaryOperator;
BEGIN
    parent <- SELF.parent()(PTerm);
    type <- parent.type();
    IF s = "*" THEN
        o := assertNumericOrSetOp(type, s, Operator.mulReal, Operator.mulInt, Operator.setIntersection);
    ELSIF s = "/" THEN
        IF Types.isInt(type) THEN
            Errors.raise("operator DIV expected for integer division");
        END;
        o := assertNumericOrSetOp(type, s, Operator.divReal, NIL, Operator.setSymmetricDiff);
    ELSIF s = "DIV" THEN
        o := assertIntOp(type, s, Operator.divInt);
    ELSIF s = "MOD" THEN
        o := assertIntOp(type, s, Operator.mod);
    ELSIF s = "&" THEN
        IF type # Types.basic.bool THEN
            Errors.raise("BOOLEAN expected as operand of '&', got '"
                                 + type.description() + "'");
        END;
        o := Operator.and;
    ELSE
        ASSERT(FALSE);
    END;

    parent.handleOperator(o);
END;

PROCEDURE Const.Const(factor: PFactor)
    | SUPER(factor),
      factor(factor);
END;

PROCEDURE Integer.handleInt(n: INTEGER);
BEGIN
    SELF.factor.handleConst(
        Types.basic.integer, 
        NEW ConstValue.Int(n), 
        String.fromInt(n));
END;

PROCEDURE Real.handleReal(r: REAL);
BEGIN
    SELF.factor.handleConst(
        Types.basic.real, 
        NEW ConstValue.Real(r), 
        String.fromReal(r));
END;

PROCEDURE escapeString(s: STRING): STRING;
CONST
    doubleQuote = Chars.doubleQuote;
    ln          = Chars.ln;
    cr          = Chars.cr;
    tab         = Chars.tab;
    backspace   = Chars.backspace;
    feed        = Chars.feed;
    backslash   = Chars.backslash;
VAR
    result: STRING;
BEGIN
    result := doubleQuote;
    from <- 0;
    FOR i <- 0 TO LEN(s) - 1 DO
        escape <- CHR(0);
        CASE s[i] OF
              backslash:    escape := backslash;
            | doubleQuote:  escape := doubleQuote;
            | ln:           escape := "n";
            | cr:           escape := "r";
            | tab:          escape := "t";
            | backspace:    escape := "b";
            | feed:         escape := "f";
        END;

        IF ORD(escape) # 0 THEN
            result := result + String.substr(s, from, i - from) + backslash + String.fromChar(escape);
            from := i + 1; 
        END;
    END;
    RETURN result + String.substr(s, from, LEN(s) - from) + doubleQuote;
END;

PROCEDURE Str.handleStr(s: STRING);
BEGIN
    SELF.factor.handleConst(
        NEW Types.String(s), 
        NEW ConstValue.String(s), 
        escapeString(s));
END;

PROCEDURE IntOpTypeCheck.expect(): STRING;
    RETURN Types.intsDescription();
END;

PROCEDURE IntOpTypeCheck.check(t: Types.PType): BOOLEAN;
    RETURN Types.isInt(t);
END;

PROCEDURE NumericOpTypeCheck.expect(): STRING;
    RETURN "numeric type";
END;

PROCEDURE NumericOpTypeCheck.check(t: Types.PType): BOOLEAN;
    RETURN Types.numeric.indexOf(t) # -1;
END;

PROCEDURE NumericOrSetOpTypeCheck.expect(): STRING;
    RETURN SUPER() + " or SET";
END;

PROCEDURE NumericOrSetOpTypeCheck.check(t: Types.PType): BOOLEAN;
    RETURN SUPER(t) OR (t = Types.basic.set);
END;

END ContextExpression.