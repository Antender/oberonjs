MODULE ContextExpression;
IMPORT 
    Chars, Code, ContextHierarchy, Operator, String, Types;
TYPE
    PFactor = POINTER TO Factor;

    Factor* = RECORD(ContextHierarchy.Node)
        PROCEDURE Factor(parent: PFactor);

        PROCEDURE handleConst(type: Types.PType; value: Code.PConst; code: STRING);
        PROCEDURE handleLiteral(s: STRING);
        PROCEDURE handleLogicalNot();
        PROCEDURE handleExpression(e: Code.PExpression);

        PROCEDURE endParse();

        factorParent: PFactor;
        logicalNot: BOOLEAN;
        e: Code.PExpression;
    END;

    Const = RECORD(ContextHierarchy.Node)
        PROCEDURE Const(factor: PFactor);

        factor: PFactor;
    END;

    Integer* = RECORD(Const)
        PROCEDURE handleInt*(n: INTEGER);
    END;

    Real* = RECORD(Const)
        PROCEDURE handleReal*(r: REAL);
    END;

    Str* = RECORD(Const)
        PROCEDURE handleStr*(s: STRING);
    END;

PROCEDURE Factor.Factor(parent: PFactor)
    | SUPER(parent),
      factorParent(parent);
END;

PROCEDURE Factor.handleConst(type: Types.PType; value: Code.PConst; code: STRING);
BEGIN
    SELF.e := Code.makeExpression(code, type, NIL, value);
END;

PROCEDURE Factor.handleLiteral(s: STRING);
BEGIN
    IF s = "NIL" THEN
        SELF.handleConst(Types.nil, NIL, "null");
    ELSIF s = "TRUE" THEN
        SELF.handleConst(Types.basic.bool, Code.makeIntConst(1), "true");
    ELSIF s = "FALSE" THEN
        SELF.handleConst(Types.basic.bool, Code.makeIntConst(0), "false");
    ELSIF s = "~" THEN
        SELF.handleLogicalNot();
    END;
END;

PROCEDURE Factor.handleLogicalNot();
BEGIN
    SELF.logicalNot := TRUE;
END;

PROCEDURE Factor.handleExpression(e: Code.PExpression);
BEGIN
    SELF.e := e;
END;

PROCEDURE Factor.endParse();
BEGIN
    IF SELF.logicalNot THEN
        ContextHierarchy.checkTypeMatch(SELF.e.type(), Types.basic.bool);
        SELF.e := Operator.not(SELF.e);
    END;
    SELF.factorParent.handleExpression(SELF.e);
END;

PROCEDURE Const.Const(factor: PFactor)
    | SUPER(factor),
      factor(factor);
END;

PROCEDURE Integer.handleInt(n: INTEGER);
BEGIN
    SELF.factor.handleConst(
        Types.basic.integer, 
        Code.makeIntConst(n), 
        String.fromInt(n));
END;

PROCEDURE Real.handleReal(r: REAL);
BEGIN
    SELF.factor.handleConst(
        Types.basic.real, 
        Code.makeRealConst(r), 
        String.fromReal(r));
END;

PROCEDURE escapeString(s: STRING): STRING;
CONST
    doubleQuote = Chars.doubleQuote;
    ln          = Chars.ln;
    cr          = Chars.cr;
    tab         = Chars.tab;
    backspace   = Chars.backspace;
    feed        = Chars.feed;
    backslash   = Chars.backslash;
VAR
    result: STRING;
BEGIN
    result := doubleQuote;
    from <- 0;
    FOR i <- 0 TO LEN(s) - 1 DO
        escape <- CHR(0);
        CASE s[i] OF
              backslash:    escape := backslash;
            | doubleQuote:  escape := doubleQuote;
            | ln:           escape := "n";
            | cr:           escape := "r";
            | tab:          escape := "t";
            | backspace:    escape := "b";
            | feed:         escape := "f";
        END;

        IF ORD(escape) # 0 THEN
            result := result + String.substr(s, from, i - from) + backslash + String.fromChar(escape);
            from := i + 1; 
        END;
    END;
    RETURN result + String.substr(s, from, LEN(s) - from) + doubleQuote;
END;

PROCEDURE Str.handleStr(s: STRING);
BEGIN
    SELF.factor.handleConst(
        NEW Types.String(s), 
        Code.makeStringConst(s), 
        escapeString(s));
END;

END ContextExpression.