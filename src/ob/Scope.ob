MODULE Scope;
IMPORT 
    Errors, 
    JsMap, 
    Object, 
    Procedures := Procedure, 
    ScopeBase,
    Symbols, 
    Types;
TYPE
    Unresolved = ARRAY * OF STRING;

    Finalizer = RECORD
        PROCEDURE Finalizer(proc: ScopeBase.FinalizerProc; closure: Object.PType);

        proc: ScopeBase.FinalizerProc;
        closure: Object.PType
    END;

    Type* = RECORD(ScopeBase.Type)
        PROCEDURE Type*(stdSymbols: JsMap.Type);

        PROCEDURE addSymbol*(s: Symbols.PSymbol; exported: BOOLEAN);
        PROCEDURE findSymbol*(id: STRING): Symbols.PFoundSymbol;
        PROCEDURE close();

        stdSymbols: JsMap.Type;
        symbols: JsMap.Type;
        unresolved: Unresolved;
        finalizers: ARRAY * OF POINTER TO Finalizer
    END;
    PType* = POINTER TO Type;

    Procedure* = RECORD(Type)
    END;

    CompiledModule = RECORD(Types.Module)
        PROCEDURE CompiledModule(name: STRING);

        PROCEDURE findSymbol(id: STRING): Symbols.PFoundSymbol;

        exports: JsMap.Type
    END;

    Module* = RECORD(Type)
        PROCEDURE Module*(name: STRING; stdSymbols: JsMap.Type);

        symbol: Symbols.PSymbol;
        exports: JsMap.Type
    END;
    PModule = POINTER TO Module;

PROCEDURE addSymbolForType*(t: Types.PBasicType; result: JsMap.Type);
VAR
    name: STRING;
BEGIN
    name := Types.typeName(t^);
    JsMap.put(result, name, NEW Symbols.Symbol(name, NEW Types.TypeId(t)));
END addSymbolForType;

PROCEDURE makeStdSymbols*(): JsMap.Type;
VAR 
    result: JsMap.Type;

    PROCEDURE addSymbol(t: Types.PBasicType);
    BEGIN
        addSymbolForType(t, result);
    END addSymbol;
BEGIN
    result := JsMap.make();
    addSymbol(Types.basic.bool);
    addSymbol(Types.basic.ch);
    addSymbol(Types.basic.integer);
    addSymbol(Types.basic.uint8);
    addSymbol(Types.basic.real);
    addSymbol(Types.basic.set); 

    FOR i <- 0 TO LEN(Procedures.predefined) - 1 DO
        proc <- Procedures.predefined[i];
        JsMap.put(result, proc.id(), proc);
    END;
    RETURN result
END makeStdSymbols;

PROCEDURE Type.Type(stdSymbols: JsMap.Type)
    | stdSymbols(stdSymbols),
      symbols(JsMap.make());
END;

PROCEDURE CompiledModule.CompiledModule(name: STRING)
    | SUPER(name),
      exports(JsMap.make());
END;

PROCEDURE Module.Module(name: STRING; stdSymbols: JsMap.Type)
    | SUPER(stdSymbols),
      symbol(NEW Symbols.Symbol(name, NEW CompiledModule(name))),
      exports(JsMap.make());
BEGIN
    SELF.addSymbol(SELF.symbol, FALSE);
END;

PROCEDURE addUnresolved*(s: Type; id: STRING);
BEGIN
    IF s.unresolved.indexOf(id) = -1 THEN
        s.unresolved.add(id);
    END;
END addUnresolved;

PROCEDURE resolve*(s: Type; symbol: Symbols.PSymbol);
VAR
    id: STRING;
    i: INTEGER;
    info: Types.PId;
    type: Types.PType;
BEGIN
    id := symbol.id();
    i := s.unresolved.indexOf(id);
    IF i # -1 THEN
        info := symbol.info();
        type := info(Types.PTypeId).type();
        IF (type # NIL) & ~(type IS Types.PRecord) THEN
            Errors.raise(
                "'" 
                + id
                + "' must be of RECORD type because it was used before in the declation of POINTER");
        END;
        s.unresolved.remove(i);
    END;
END resolve;

PROCEDURE unresolved*(s: Type): Unresolved;
    RETURN s.unresolved
END unresolved;

PROCEDURE Type.close();
BEGIN
    FOR i <- LEN(SELF.finalizers) - 1 TO 0 BY -1 DO
        finalizer <- SELF.finalizers[i];
        finalizer.proc(finalizer.closure);
    END;

    (* make second close() call safe and free memory *)
    SELF.finalizers.clear(); 
END Type.close;

PROCEDURE Finalizer.Finalizer(proc: ScopeBase.FinalizerProc; closure: Object.PType)
    | proc(proc),
      closure(closure);
END;

PROCEDURE Type.addFinalizer(proc: ScopeBase.FinalizerProc; closure: Object.PType);
BEGIN
    SELF.finalizers.add(NEW Finalizer(proc, closure));
END;

PROCEDURE close*(s: Type): Unresolved;
    RETURN s.unresolved
END close;

PROCEDURE Type.addSymbol(s: Symbols.PSymbol; exported: BOOLEAN);
VAR
    id: STRING;
BEGIN
    id := s.id();
    IF SELF.findSymbol(id) # NIL THEN
        Errors.raise("'" + id + "' already declared");
    END;
    JsMap.put(SELF.symbols, id, s);
END Type.addSymbol;

PROCEDURE Type.findSymbol(id: STRING): Symbols.PFoundSymbol;
VAR
    result: Object.PType;
    found: Symbols.PFoundSymbol;
BEGIN
    IF ~JsMap.find(SELF.symbols, id, result) THEN
        void <- JsMap.find(SELF.stdSymbols, id, result);
    END;
    IF result # NIL THEN
        found := NEW Symbols.FoundSymbol(result(Symbols.PSymbol), SELF(POINTER))
    END;
    RETURN found
END Type.findSymbol;

PROCEDURE Procedure.name(): STRING;
    RETURN "procedure"
END Procedure.name;

PROCEDURE Procedure.addSymbol(s: Symbols.PSymbol; exported: BOOLEAN);
VAR
    info: Types.PId;
BEGIN
    IF exported THEN
        info := s.info();
        Errors.raise("cannot export from within procedure: "
                     + info.idType() + " '" + s.id() + "'");
    END;
    SUPER(s, exported);
END Procedure.addSymbol;

PROCEDURE makeProcedure*(stdSymbols: JsMap.Type): PType;
    RETURN NEW Procedure(stdSymbols);
END;

PROCEDURE addExport(id: STRING; value: Object.PType; VAR closure: Object.Type);
VAR
    symbol: Symbols.PSymbol;
    info: Types.PId;
BEGIN
    symbol := value(Symbols.PSymbol);
    info := symbol.info();
    IF info IS Types.PVariable THEN
        symbol := NEW Symbols.Symbol(id, Types.makeExportedVariable(info(Types.PVariable)^));
    END;
    JsMap.put(closure(CompiledModule).exports, id, symbol);
END addExport;

PROCEDURE defineExports*(VAR m: CompiledModule; exports: JsMap.Type);
BEGIN
    JsMap.forEach(exports, addExport, m);
END defineExports;

PROCEDURE CompiledModule.findSymbol(id: STRING): Symbols.PFoundSymbol;
VAR
    s: Object.PType;
    result: Symbols.PFoundSymbol;
BEGIN
    IF JsMap.find(SELF.exports, id, s) THEN
        result := NEW Symbols.FoundSymbol(s(Symbols.PSymbol), NIL);
    END;
    RETURN result
END CompiledModule.findSymbol;

PROCEDURE Module.name(): STRING;
    RETURN "module"
END Module.name;

PROCEDURE Module.addSymbol(s: Symbols.PSymbol; exported: BOOLEAN);
BEGIN
    SUPER(s, exported);
    IF exported THEN
        JsMap.put(SELF.exports, s.id(), s);
    END;
END Module.addSymbol;

PROCEDURE moduleSymbol*(m: Module): Symbols.PSymbol;
    RETURN m.symbol
END moduleSymbol;

PROCEDURE moduleExports*(m: Module): JsMap.Type;
    RETURN m.exports
END moduleExports;

END Scope.