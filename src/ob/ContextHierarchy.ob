MODULE ContextHierarchy;
IMPORT Cast, Code, CodeGenerator, Errors, LanguageContext, Module, Scope, Symbols, String, Types;
TYPE
    PRoot = POINTER TO Root;
    PNode = POINTER TO Node;

    Message = RECORD
    END;

    PMessageResult = POINTER TO RECORD
    END;

    QIdent = RECORD
        module: Module.PType;
        id: STRING;
        code: STRING;
    END;

    Attributes* = RECORD
    END;

    Node* = RECORD
        PROCEDURE Node*(parent: PNode);

        PROCEDURE root(): PRoot;
        PROCEDURE parent(): PNode;
        PROCEDURE handleMessage(VAR msg: Message): PMessageResult;
        PROCEDURE codeGenerator(): CodeGenerator.PIGenerator;
        PROCEDURE qualifyScope(scope: Scope.PType): STRING;
        PROCEDURE handleLiteral(s: STRING);
        PROCEDURE genTypeName(): STRING;

        mParent: PNode;
        attributes*: Attributes;
    END;

    Root* = RECORD(Node)
        PROCEDURE Root(language: LanguageContext.PType);

        PROCEDURE language(): LanguageContext.PType;

        PROCEDURE findSymbol(ident: STRING): Symbols.PFoundSymbol;
        PROCEDURE findModule(name: STRING): Types.PModule;

        PROCEDURE currentScope(): Scope.PType;
        PROCEDURE pushScope(scope: Scope.PType);
        PROCEDURE popScope();

        mLanguage: LanguageContext.PType;
        scopes: ARRAY * OF Scope.PType;
        gen: INTEGER;
    END;

PROCEDURE Node.Node(parent: PNode)
    | mParent(parent);
BEGIN
    IF parent # NIL THEN
        SELF.attributes := parent.attributes;
    END;
END;

PROCEDURE Node.root(): PRoot;
    RETURN SELF.mParent.root();
END;

PROCEDURE Node.parent(): PNode;
    RETURN SELF.mParent;
END;

PROCEDURE Node.handleMessage(VAR msg: Message): PMessageResult;
    RETURN SELF.mParent.handleMessage(msg);
END;

PROCEDURE Node.codeGenerator(): CodeGenerator.PIGenerator;
    RETURN SELF.mParent.codeGenerator();
END;

PROCEDURE Node.qualifyScope(scope: Scope.PType): STRING;
    RETURN SELF.mParent.qualifyScope(scope);
END;

PROCEDURE Node.handleLiteral(s: STRING);
END;

PROCEDURE Node.genTypeName(): STRING;
    RETURN SELF.mParent.genTypeName();
END;

PROCEDURE Root.Root(language: LanguageContext.PType)
    | SUPER(NIL),
      mLanguage(language);
END;

PROCEDURE Root.language(): LanguageContext.PType;
    RETURN SELF.mLanguage;
END;

PROCEDURE Root.genTypeName(): STRING;
BEGIN
    INC(SELF.gen);
    RETURN "anonymous$" + String.fromInt(SELF.gen);
END;

PROCEDURE Root.findSymbol(ident: STRING): Symbols.PFoundSymbol;
VAR
    result: Symbols.PFoundSymbol;
BEGIN
    i <- LEN(SELF.scopes);
    WHILE (i # 0) & (result = NIL) DO
        DEC(i);
        scope <- SELF.scopes[i];
        result := scope.findSymbol(ident);
    END;
    RETURN result;
END;

PROCEDURE Root.findModule(name: STRING): Types.PModule;
VAR
    result: Types.PModule;
BEGIN
    IF name = "JS" THEN
        result := Module.makeJS();
    ELSIF SELF.mLanguage.moduleResolver # NIL THEN
        result := SELF.mLanguage.moduleResolver(name);
    END;
    RETURN result;
END;

PROCEDURE Root.currentScope(): Scope.PType;
    RETURN SELF.scopes[LEN(SELF.scopes) - 1];
END;

PROCEDURE Root.pushScope(scope: Scope.PType);
BEGIN
    SELF.scopes.add(scope);
END;

PROCEDURE Root.popScope();
BEGIN
    i <- LEN(SELF.scopes) - 1;
    SELF.scopes[i].close();
    SELF.scopes.remove(i);
END;

PROCEDURE Root.codeGenerator(): CodeGenerator.PIGenerator;
    RETURN SELF.mLanguage.codeGenerator;
END;

PROCEDURE Root.root(): PRoot;
    RETURN SELF(POINTER);
END;

PROCEDURE getSymbolAndScope*(cx: Root; id: STRING): Symbols.PFoundSymbol;
BEGIN
    s <- cx.findSymbol(id);
    IF s = NIL THEN
        Errors.raise("undeclared identifier: '" + id + "'");
    END;
    RETURN s;
END;

PROCEDURE getModuleSymbolAndScope*(m: Module.Type; id: STRING): Symbols.PFoundSymbol;
BEGIN
    s <- m.findSymbol(id);
    IF s = NIL THEN
        Errors.raise("identifier '" + id + "' is not exported by module '" + m.name + "'");
    END;
    RETURN s;
END;

PROCEDURE getQIdSymbolAndScope*(cx: Root; q: QIdent): Symbols.PFoundSymbol;
VAR 
    result: Symbols.PFoundSymbol;
BEGIN
    IF q.module # NIL THEN
        result := getModuleSymbolAndScope(q.module^, q.id);
    ELSE
        result := getSymbolAndScope(cx, q.id);
    END;
    RETURN result;
END;

PROCEDURE getSymbol*(cx: Root; id: STRING): Symbols.PSymbol;
    RETURN getSymbolAndScope(cx, id).symbol();
END;

PROCEDURE unwrapTypeId*(id: Types.PId): Types.PTypeId;
VAR
    result: Types.PTypeId;
BEGIN
    IF ~(id IS Types.PTypeId) THEN
        Errors.raise("type name expected");
    ELSE
        result := id;
    END;
    RETURN result;
END;

PROCEDURE unwrapType*(id: Types.PId): Types.PType;
    RETURN unwrapTypeId(id).type();
END;

PROCEDURE throwTypeMismatch(from, to: Types.PType);
BEGIN
    Errors.raise("type mismatch: expected '" + to.description() 
               + "', got '" + from.description() + "'");
END;

PROCEDURE checkTypeMatch*(from, to: Types.PType);
BEGIN
    IF ~Cast.areTypesMatch(from, to) THEN
        throwTypeMismatch(from, to);
    END;
END;

PROCEDURE checkImplicitCast*(cx: Root; from, to: Types.PType);
VAR
    op: LanguageContext.PCastOp;
BEGIN
    IF cx.language().types.implicitCast(from, to, FALSE, op) # Cast.errNo THEN
        throwTypeMismatch(from, to);
    END;
END;

PROCEDURE promoteTypeInExpression*(e: Code.PExpression; type: Types.PType): Code.PExpression;
VAR
    v: CHAR;
    result: Code.PExpression;
BEGIN
    fromType <- e.type();
    IF (type = Types.basic.ch) & (fromType IS Types.PString) & Types.stringAsChar(fromType^, v) THEN
        result := Code.makeSimpleExpression(String.fromInt(ORD(v)), type);
    ELSE
        result := e;
    END;
    RETURN result;
END;

PROCEDURE promoteExpressionType*(cx: Root; left, right: Code.PExpression);
BEGIN
    IF left # NIL THEN
        rightType <- right.type();
        leftType <- left.type();
        IF (leftType # NIL) & (rightType # NIL) THEN
            checkImplicitCast(cx, rightType, leftType);
        END;
    END;
END;

PROCEDURE checkTypeCast*(fromInfo: Types.Variable; fromType, toType: Types.PType; msg: STRING);
VAR
    PROCEDURE checkCommonBase(from, to: Types.PRecord; prefix: STRING);
    BEGIN
        t <- to.base;
        WHILE (t # NIL) & (t # from) DO
            t := t.base;
        END;
        IF t = NIL THEN
            Errors.raise(prefix + ": '" + to.description()
                       + "' is not an extension of '" + from.description() + "'");
        END;
    END;

BEGIN
    prefix <- "invalid " + msg;

    pointerExpected <- fromType IS Types.PPointer;
    IF ~pointerExpected & ~(fromType IS Types.PRecord) THEN
        Errors.raise(
            prefix + ": POINTER to type or RECORD expected, got '"
            + fromType.description() + "'");
    END;

    IF ~pointerExpected THEN
        IF ~fromInfo.isReference() THEN
            Errors.raise(
                prefix + ": a value variable cannot be used");
        ELSIF ~(toType IS Types.PRecord) THEN
            Errors.raise(
                prefix + ": RECORD type expected as an argument of RECORD " + msg + ", got '"
              + toType.description() + "'");
        END;
    ELSIF ~(toType IS Types.PPointer) THEN
        Errors.raise(
            prefix + ": POINTER type expected as an argument of POINTER " + msg + ", got '"
          + toType.description() + "'");
    END;

    IF pointerExpected THEN
        checkCommonBase(Types.pointerBase(fromType(Types.PPointer)^), 
                        Types.pointerBase(toType(Types.PPointer)^), 
                        prefix);
    ELSE
        checkCommonBase(fromType(Types.PRecord), 
                        toType(Types.PRecord), 
                        prefix);
    END;
END checkTypeCast;

END ContextHierarchy.