MODULE ContextCase;
IMPORT
    Cast, Chars, CodeGenerator, ConstValue, ContextExpression, ContextHierarchy, 
    Errors, Expression, Record, Scope, String, Symbols, TypeId, Types, Variable;
TYPE
    Type* = RECORD(ContextExpression.ExpressionHandler)
        PROCEDURE Type(parent: ContextHierarchy.PNode);

        PROCEDURE beginCase();
        PROCEDURE handleLabelType(type: Types.PType);

        var: STRING;
        type: Types.PType;
        guardVar: Types.PDeclaredVariable;
        typeTest: Expression.PType;
        firstCaseParsed: BOOLEAN;
    END;
    PType = POINTER TO Type;

    Label* = RECORD(ContextHierarchy.Node)
        PROCEDURE caseLabelBegin();
        PROCEDURE caseLabelEnd();
        PROCEDURE handleTypeGuard(e: Expression.PType; info: TypeId.PType);
    END;
    PLabel = POINTER TO Label;

    LabelList* = RECORD(ContextHierarchy.Node)
        PROCEDURE handleRange(from, to: ConstValue.PInt);

        glue: STRING;
    END;

    Range* = RECORD(ContextExpression.ExpressionHandler)
        from, to: ConstValue.PInt;
    END;

    GuardedVariable = RECORD(Types.Variable)
        PROCEDURE GuardedVariable(caseVariable: Types.PVariable; guardedType: Types.PStorageType);

        caseVariable: Types.PVariable;
        guardedType: Types.PStorageType;
    END;

PROCEDURE Type.Type(parent: ContextHierarchy.PNode)
    | SUPER(parent),
      var(SELF.root().currentScope().generateTempVar("case"));
BEGIN
    SELF.codeGenerator().write("var " + SELF.var + " = ");
END;

PROCEDURE Type.handleExpression(e: Expression.PType);
VAR
    c: CHAR;
BEGIN
    type <- e.type();
    gen <- SELF.codeGenerator();
    IF (type IS Types.PString) & Types.stringAsChar(type^, c) THEN
        gen.write(String.fromChar(c));
        SELF.type := Types.basic.ch;
    ELSIF Types.isInt(type) OR (type = Types.basic.ch) THEN
        SELF.type := type;
    ELSIF (type IS Record.PPointer) OR (type IS Types.PRecord) THEN
        d <- e.designator();
        IF d # NIL THEN
            info <- e.designator().info();
            IF info IS Types.PVariable THEN
                IF ~info.isReference() & (type IS Types.PRecord) THEN
                    Errors.raise("only records passed as VAR argument can be used to test type in CASE");
                END;
                IF info IS Types.PDeclaredVariable THEN
                    SELF.guardVar := info;
                END;
            END;
        END;
        SELF.typeTest := e;
    ELSE
        Errors.raise("'RECORD' or 'POINTER' or "
                     + Types.intsDescription() + " or 'CHAR' expected as CASE expression");
    END;
    gen.write(";" + Chars.ln);
END;

PROCEDURE Type.beginCase();
BEGIN
    IF ~SELF.firstCaseParsed THEN
        SELF.firstCaseParsed := TRUE;
    ELSE
        SELF.codeGenerator().write("else ");
    END;
END;

PROCEDURE Type.handleLabelType(type: Types.PType);
BEGIN
    IF ~Cast.areTypesMatch(type, SELF.type) THEN
        Errors.raise("label must be '" + SELF.type.description() + "' (the same as case expression), got '"
                     + type.description() + "'");
    END;
END;

PROCEDURE LabelList.handleRange(from, to: ConstValue.PInt);
VAR
    cond: STRING;
BEGIN
    parent <- SELF.parent()(PLabel);
    IF LEN(SELF.glue) = 0 THEN
        parent.caseLabelBegin();
    END;

    v <- parent.parent()^(Type).var;
    IF to = NIL THEN
        cond := v + " === " + String.fromInt(from.value);
    ELSE
        cond := "(" + v + " >= " + String.fromInt(from.value)
              + " && " + v + " <= " + String.fromInt(to.value) + ")";
    END;

    SELF.codeGenerator().write(SELF.glue + cond);
    SELF.glue := " || ";
END;

PROCEDURE LabelList.endParse(): BOOLEAN;
BEGIN
    SELF.parent()(PLabel).caseLabelEnd();
    RETURN TRUE;
END;

PROCEDURE contextFromLabel(l: Label): PType;
    RETURN l.parent()(PType);
END;

PROCEDURE Label.caseLabelBegin();
BEGIN
    contextFromLabel(SELF).beginCase();
    SELF.codeGenerator().write("if (");
END;

PROCEDURE Label.caseLabelEnd();
BEGIN
    gen <- SELF.codeGenerator();
    gen.write(")");
    gen.openScope();
END;

PROCEDURE Label.handleTypeGuard(e: Expression.PType; info: TypeId.PType);
BEGIN
    guardVar <- contextFromLabel(SELF).guardVar;
    IF guardVar # NIL THEN
        root <- SELF.root();
        scope <- NEW Scope.Procedure(root.language().stdSymbols);
        root.pushScope(scope);
        scope.addSymbol(NEW Symbols.Symbol(guardVar.id(), NEW GuardedVariable(guardVar, info.type())), FALSE);
    END;

    SELF.codeGenerator().write(ContextExpression.typeTest(e, info, SELF).code());
END;

PROCEDURE Label.endParse(): BOOLEAN;
BEGIN
    IF contextFromLabel(SELF).guardVar # NIL THEN
        SELF.root().popScope();
    END;
    SELF.codeGenerator().closeScope("");
    RETURN TRUE;
END;

PROCEDURE labelContext(VAR r: Range): PLabel;
    RETURN r.parent().parent()(PLabel);
END;

PROCEDURE caseContext(VAR r: Range): PType;
    RETURN labelContext(r).parent()(PType);
END;

PROCEDURE handleLabel(VAR r: Range; type: Types.PType; v: ConstValue.PInt);
BEGIN
    caseContext(r).handleLabelType(type);
    IF r.from = NIL THEN
        r.from := v;
    ELSE
        r.to := v;
    END;
END;

PROCEDURE Range.codeGenerator(): CodeGenerator.PIGenerator;
    RETURN CodeGenerator.nullGenerator;
END;

PROCEDURE Range.handleExpression(e: Expression.PType);
VAR
    c: CHAR;
BEGIN
    IF caseContext(SELF).typeTest # NIL THEN
        Errors.raise("type's name expected in label, got expression: " + e.code());
    END;

    type <- e.type();
    IF type IS Types.PString THEN
        IF ~Types.stringAsChar(type^, c) THEN
            Errors.raise("single-character string expected");
        END;
        handleLabel(SELF, Types.basic.ch, NEW ConstValue.Int(ORD(c)));
    ELSE
        handleLabel(SELF, type, e.constValue()(ConstValue.PInt));
    END;
END;

PROCEDURE Range.handleIdent(id: STRING);
BEGIN
    info <- ContextHierarchy.getSymbol(SELF.root()^, id).info();
    typeTest <- caseContext(SELF).typeTest;
    IF typeTest # NIL THEN
        IF info IS TypeId.PType THEN
            labelContext(SELF).handleTypeGuard(typeTest, info);
        ELSE
            Errors.raise("'" + id + "' is not a type");
        END;
    ELSIF ~(info IS Types.PConst) THEN
        Errors.raise("'" + id + "' is not a constant");
    ELSE
        type <- info.type;
        IF type IS Types.PString THEN
            SELF.handleExpression(Expression.makeSimple("", type));
        ELSE
            handleLabel(SELF, type, info.value(ConstValue.PInt));
        END;
    END;
END;

PROCEDURE Range.endParse(): BOOLEAN;
BEGIN
    IF SELF.from # NIL THEN
        SELF.parent()^(LabelList).handleRange(SELF.from, SELF.to);
    END;
    RETURN TRUE;
END;

PROCEDURE GuardedVariable.GuardedVariable(caseVariable: Types.PVariable; guardedType: Types.PStorageType)
    | caseVariable(caseVariable),
      guardedType(guardedType);
END;

PROCEDURE GuardedVariable.type(): Types.PStorageType;
    RETURN SELF.guardedType;
END;

PROCEDURE GuardedVariable.isReadOnly(): BOOLEAN;
    RETURN SELF.caseVariable.isReadOnly();
END;

PROCEDURE GuardedVariable.isReference(): BOOLEAN;
    RETURN SELF.caseVariable.isReference();
END;

PROCEDURE GuardedVariable.referenceCode(): STRING;
    RETURN SELF.caseVariable.referenceCode();
END;

END ContextCase.