MODULE ContextCase;
IMPORT
    Cast, Chars, CodeGenerator, ConstValue, ContextExpression, ContextHierarchy,
    Designator, Errors, Expression, 
    Record, Scope, String, Symbols, TypeId, Types, Variable;
TYPE
    Type* = RECORD(ContextExpression.ExpressionHandler)
        PROCEDURE Type(parent: ContextHierarchy.PNode);

        PROCEDURE beginCase();
        PROCEDURE handleLabelType(type: Types.PType);

        mCodeGenerator: CodeGenerator.PIGenerator;
        var: STRING;
        type: Types.PType;
        guardVar: Types.PDeclaredVariable;
        typeTest: Expression.PType;
        firstCaseParsed: BOOLEAN;
    END;
    PType = POINTER TO Type;

    Label* = RECORD(ContextHierarchy.Node)
        PROCEDURE caseLabelBegin();
        PROCEDURE caseLabelEnd();
        PROCEDURE handleTypeGuard(e: Expression.PType; info: TypeId.PType);
    END;
    PLabel = POINTER TO Label;

    LabelList* = RECORD(ContextHierarchy.Node)
        PROCEDURE handleRange(from, to: ConstValue.PInt);

        glue: STRING;
    END;

    Range* = RECORD(ContextExpression.ExpressionHandler)
        from, to: ConstValue.PInt;
    END;

    GuardedVariable = RECORD(Types.Variable)
        PROCEDURE GuardedVariable(caseVariable: Types.PVariable; guardedType: Types.PStorageType);

        caseVariable: Types.PVariable;
        guardedType: Types.PStorageType;
    END;

PROCEDURE Type.Type(parent: ContextHierarchy.PNode)
    | SUPER(parent),
      mCodeGenerator(CodeGenerator.nullGenerator);
END;

PROCEDURE Type.codeGenerator(): CodeGenerator.PIGenerator;
    RETURN SELF.mCodeGenerator;
END;

PROCEDURE Type.handleExpression(e: Expression.PType);
VAR
    c: CHAR;
    declVar: Types.PDeclaredVariable;

    PROCEDURE infoFromExpression(): Types.PId;
    VAR
        result: Types.PId;
    BEGIN
        d <- e.designator();
        IF d # NIL THEN
            result := d.info();
        END;
        RETURN result;
    END;

BEGIN
    normExp <- e;
    type <- e.type();
    IF (type IS Types.PString) & Types.stringAsChar(type^, c) THEN
        normExp := Expression.makeSimple(String.fromInt(ORD(c)), Types.basic.ch);
    ELSE
        info <- infoFromExpression();
        IF info IS Types.PDeclaredVariable THEN
            declVar := info;
            IF ~info.isReference() THEN
                SELF.var := declVar.id();
            END;
        END;

        IF (type IS Types.PRecord) OR (type IS Record.PPointer) THEN
            isReference <- (info IS Types.PVariable) & info.isReference();
            IF (type IS Types.PRecord) & ~isReference THEN
                Errors.raise("only records passed as VAR argument can be used to test type in CASE");
            ELSIF ~(type IS Record.PPointer) OR ~isReference THEN
                SELF.guardVar := declVar;
            END;

            SELF.typeTest := e;
        ELSIF ~Types.isInt(type) & (type # Types.basic.ch) THEN
            Errors.raise("'RECORD' or 'POINTER' or "
                         + Types.intsDescription() + " or 'CHAR' expected as CASE expression");
        END;
    END;

    SELF.type := normExp.type();

    SELF.mCodeGenerator := SELF.parent().codeGenerator();
    IF LEN(SELF.var) = 0 THEN
        SELF.var := SELF.root().currentScope().generateTempVar("case");
        SELF.mCodeGenerator.write("var " + SELF.var + " = " + Expression.deref(normExp).code() + ";" + Chars.ln);
        
        IF SELF.typeTest # NIL THEN
            SELF.typeTest := Expression.makeSimple(SELF.var, type);
        END;
    END;
END;

PROCEDURE Type.beginCase();
BEGIN
    IF ~SELF.firstCaseParsed THEN
        SELF.firstCaseParsed := TRUE;
    ELSE
        SELF.codeGenerator().write("else ");
    END;
END;

PROCEDURE Type.handleLabelType(type: Types.PType);
BEGIN
    IF ~Cast.areTypesMatch(type, SELF.type) THEN
        Errors.raise("label must be '" + SELF.type.description() + "' (the same as case expression), got '"
                     + type.description() + "'");
    END;
END;

PROCEDURE LabelList.handleRange(from, to: ConstValue.PInt);
VAR
    cond: STRING;
BEGIN
    parent <- SELF.parent()(PLabel);
    IF LEN(SELF.glue) = 0 THEN
        parent.caseLabelBegin();
    END;

    IF from # NIL THEN
        v <- parent.parent()^(Type).var;
        IF to = NIL THEN
            cond := v + " === " + String.fromInt(from.value);
        ELSE
            cond := "(" + v + " >= " + String.fromInt(from.value)
                  + " && " + v + " <= " + String.fromInt(to.value) + ")";
        END;
    END;

    SELF.codeGenerator().write(SELF.glue + cond);
    SELF.glue := " || ";
END;

PROCEDURE LabelList.endParse(): BOOLEAN;
BEGIN
    SELF.parent()(PLabel).caseLabelEnd();
    RETURN TRUE;
END;

PROCEDURE contextFromLabel(l: Label): PType;
    RETURN l.parent()(PType);
END;

PROCEDURE Label.caseLabelBegin();
BEGIN
    contextFromLabel(SELF).beginCase();
    SELF.codeGenerator().write("if (");
END;

PROCEDURE Label.caseLabelEnd();
BEGIN
    gen <- SELF.codeGenerator();
    gen.write(")");
    gen.openScope();
END;

PROCEDURE Label.handleTypeGuard(e: Expression.PType; info: TypeId.PType);
BEGIN
    SELF.caseLabelBegin();
    guardVar <- contextFromLabel(SELF).guardVar;
    IF guardVar # NIL THEN
        root <- SELF.root();
        scope <- NEW Scope.Procedure(root.language().stdSymbols);
        root.pushScope(scope);
        scope.addSymbol(NEW Symbols.Symbol(guardVar.id(), NEW GuardedVariable(guardVar, info.type())), FALSE);
    END;

    SELF.codeGenerator().write(ContextExpression.typeTest(e, info, SELF).code());
END;

PROCEDURE Label.endParse(): BOOLEAN;
BEGIN
    IF contextFromLabel(SELF).guardVar # NIL THEN
        SELF.root().popScope();
    END;
    SELF.codeGenerator().closeScope("");
    RETURN TRUE;
END;

PROCEDURE labelContext(VAR r: Range): PLabel;
    RETURN r.parent().parent()(PLabel);
END;

PROCEDURE caseContext(VAR r: Range): PType;
    RETURN labelContext(r).parent()(PType);
END;

PROCEDURE handleLabel(VAR r: Range; type: Types.PType; v: ConstValue.PInt);
BEGIN
    caseContext(r).handleLabelType(type);
    IF r.from = NIL THEN
        r.from := v;
    ELSE
        r.to := v;
    END;
END;

PROCEDURE Range.codeGenerator(): CodeGenerator.PIGenerator;
    RETURN CodeGenerator.nullGenerator;
END;

PROCEDURE Range.handleExpression(e: Expression.PType);
VAR
    c: CHAR;
BEGIN
    IF caseContext(SELF).typeTest # NIL THEN
        Errors.raise("type's name expected in label, got expression: " + e.code());
    END;

    type <- e.type();
    IF type IS Types.PString THEN
        IF ~Types.stringAsChar(type^, c) THEN
            Errors.raise("single-character string expected");
        END;
        handleLabel(SELF, Types.basic.ch, NEW ConstValue.Int(ORD(c)));
    ELSE
        handleLabel(SELF, type, e.constValue()(ConstValue.PInt));
    END;
END;

PROCEDURE Range.handleIdent(id: STRING);
BEGIN
    info <- ContextHierarchy.getSymbol(SELF.root()^, id).info();
    typeTest <- caseContext(SELF).typeTest;
    IF typeTest # NIL THEN
        IF info IS TypeId.PType THEN
            labelContext(SELF).handleTypeGuard(typeTest, info);
        ELSE
            Errors.raise("'" + id + "' is not a type");
        END;
    ELSIF ~(info IS Types.PConst) THEN
        Errors.raise("'" + id + "' is not a constant");
    ELSE
        type <- info.type;
        IF type IS Types.PString THEN
            SELF.handleExpression(Expression.makeSimple("", type));
        ELSE
            handleLabel(SELF, type, info.value(ConstValue.PInt));
        END;
    END;
END;

PROCEDURE Range.endParse(): BOOLEAN;
BEGIN
    IF SELF.from # NIL THEN
        SELF.parent()^(LabelList).handleRange(SELF.from, SELF.to);
    END;
    RETURN TRUE;
END;

PROCEDURE GuardedVariable.GuardedVariable(caseVariable: Types.PVariable; guardedType: Types.PStorageType)
    | caseVariable(caseVariable),
      guardedType(guardedType);
END;

PROCEDURE GuardedVariable.type(): Types.PStorageType;
    RETURN SELF.guardedType;
END;

PROCEDURE GuardedVariable.isReadOnly(): BOOLEAN;
    RETURN SELF.caseVariable.isReadOnly();
END;

PROCEDURE GuardedVariable.isReference(): BOOLEAN;
    RETURN SELF.caseVariable.isReference();
END;

PROCEDURE GuardedVariable.referenceCode(): STRING;
    RETURN SELF.caseVariable.referenceCode();
END;

END ContextCase.