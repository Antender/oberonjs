MODULE JsMap;
IMPORT JS, Object;
TYPE
    Type* = POINTER TO RECORD END;
    Keys = ARRAY * OF STRING;
    ForEachProc = PROCEDURE(key: STRING; value: Object.PType; VAR closure: Object.Type);
    
    Strings* = POINTER TO RECORD END;
    ForEachStringProc = PROCEDURE(key: STRING; value: STRING; VAR closure: Object.Type);

PROCEDURE make*(): Type;
VAR
    result: Type;
BEGIN
    JS.do("result = {}");
    RETURN result    
END make;

PROCEDURE makeStrings*(): Strings;
VAR
    result: Strings;
BEGIN
    JS.do("result = {}");
    RETURN result    
END;

PROCEDURE has*(m: Type; s: STRING): BOOLEAN;
VAR
    result: BOOLEAN;
BEGIN
    JS.do("result = m.hasOwnProperty(s)");
    RETURN result
END;

PROCEDURE hasString*(m: Strings; s: STRING): BOOLEAN;
VAR
    result: BOOLEAN;
BEGIN
    JS.do("result = m.hasOwnProperty(s)");
    RETURN result
END;

PROCEDURE find*(m: Type; s: STRING; VAR r: Object.PType): BOOLEAN;
VAR
    result: BOOLEAN;
BEGIN
    JS.do("if (m.hasOwnProperty(s)){result = true; r.set(m[s]);}");
    RETURN result
END find;

PROCEDURE findString*(m: Strings; s: STRING; VAR r: STRING): BOOLEAN;
VAR
    result: BOOLEAN;
BEGIN
    JS.do("if (m.hasOwnProperty(s)){result = true; r.set(m[s]);}");
    RETURN result
END;

PROCEDURE put*(m: Type; s: STRING; o: Object.PType);
BEGIN
    JS.do("m[s] = o");
END put;

PROCEDURE putString*(m: Strings; s: STRING; v: STRING);
BEGIN
    JS.do("m[s] = v");
END;

PROCEDURE erase*(m: Type; s: STRING);
BEGIN
    JS.do("delete m[s]");
END erase;

PROCEDURE keys*(m: Type): Keys;
VAR
    result: ARRAY * OF STRING;
BEGIN
    JS.do("result = JS.Object.keys(m);");
    RETURN result;
END;

PROCEDURE forEach*(m: Type; p: ForEachProc; VAR closure: Object.Type);
BEGIN
    JS.do("for(var key in m){p(key, m[key], closure)}");
END forEach;

PROCEDURE forEachString*(m: Strings; p: ForEachStringProc; VAR closure: Object.Type);
BEGIN
    JS.do("for(var key in m){p(key, m[key], closure)}");
END forEachString;

END JsMap.