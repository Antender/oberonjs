MODULE JsString;
IMPORT JS;

TYPE
    Type* = POINTER TO RECORD END;

PROCEDURE make*(s: ARRAY OF CHAR): Type;
VAR 
    result: Type;
    i: INTEGER;
BEGIN
    JS.do("result = ''");
    FOR i := 0 TO LEN(s) - 1 DO
        JS.do("result += JS.String.fromCharCode(s.charCodeAt(i))")
    END
    RETURN result
END make;

PROCEDURE makeEmpty*(): Type;
VAR 
    result: Type;
BEGIN
    JS.do("result = ''");
    RETURN result
END makeEmpty;

PROCEDURE fromInt*(i: INTEGER): Type;
VAR 
    result: Type;
BEGIN
    JS.do("result = '' + i");
    RETURN result
END fromInt;

PROCEDURE len*(self: Type): INTEGER;
VAR result: INTEGER;
BEGIN
    JS.do("result = self.length");
    RETURN result
END len;

PROCEDURE at*(self: Type; pos: INTEGER): CHAR;
VAR result: CHAR;
BEGIN
    JS.do("result = self.charCodeAt(pos)")
    RETURN result
END at;

PROCEDURE indexOf*(self: Type; c: CHAR): INTEGER;
VAR result: INTEGER;
BEGIN
    JS.do("result = self.indexOf(JS.String.fromCharCode(c))")
    RETURN result
END indexOf;

PROCEDURE indexOfFrom*(self: Type; c: CHAR; pos: INTEGER): INTEGER;
VAR result: INTEGER;
BEGIN
    JS.do("result = self.indexOf(JS.String.fromCharCode(c), pos)")
    RETURN result
END indexOfFrom;

PROCEDURE substr*(self: Type; pos: INTEGER; len: INTEGER): Type;
VAR result: Type;
BEGIN
    JS.do("result = self.substr(pos, len)")
    RETURN result
END substr;

PROCEDURE appendChar*(self: Type; c: CHAR): Type;
VAR result: Type;
BEGIN
    result := self;
    JS.do("result += JS.String.fromCharCode(c)")
    RETURN result
END appendChar;

PROCEDURE concat*(self: Type; add: Type): Type;
VAR result: Type;
BEGIN
    JS.do("result = self + add");
    RETURN result
END concat;

PROCEDURE eq*(s1, s2: Type): BOOLEAN;
VAR result: BOOLEAN;
BEGIN
    JS.do("result = s1 == s2");
    RETURN result
END eq;

END JsString.