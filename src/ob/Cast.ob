MODULE Cast;
IMPORT Code, OberonRtl, String, Types;
CONST
    errNo* = 0;
    err* = 1;
    errVarParameter* = 2;
TYPE
    CastOp* = RECORD
        PROCEDURE make*(rtl: OberonRtl.PType; e: Code.PExpression): Code.PExpression;
        PROCEDURE assign*(rtl: OberonRtl.PType; left, right: Code.PExpression): STRING
    END;

    PCastOp* = POINTER TO CastOp;

    CastOpDoNothing* = RECORD (CastOp)
    END;

    CastOpArray = RECORD (CastOpDoNothing)
    END;

    CastOpRecord = RECORD (CastOpDoNothing)
    END;

    CastOpStrToChar = RECORD (CastOpDoNothing)
    END;

    Operations* = RECORD
        castToUint8*: PCastOp
    END;

VAR
    (*workaround recursive usage*)
    areTypesExactlyMatch*: PROCEDURE (t1: Types.PType; t2: Types.PType): BOOLEAN;

    doNothing*: POINTER TO CastOpDoNothing;
    castOpStrToChar: POINTER TO CastOpStrToChar;
    castOpArray: POINTER TO CastOpArray;
    castOpRecord: POINTER TO CastOpRecord;

PROCEDURE findBaseType(base: Types.PRecord; type: Types.PRecord): Types.PRecord;
BEGIN
    result <- type;
    WHILE (result # NIL) & (result # base) DO
        result := Types.recordBase(result^);
    END;
    RETURN result
END findBaseType;

PROCEDURE findPointerBaseType*(base: Types.PPointer; type: Types.Pointer): Types.PPointer;
VAR
    result: Types.PPointer;
BEGIN
    IF findBaseType(Types.pointerBase(base^), Types.pointerBase(type)) # NIL THEN
        result := base;
    END;
    RETURN result
END findPointerBaseType;

PROCEDURE matchesToNIL(VAR t: Types.Type): BOOLEAN;
    RETURN (t IS Types.Pointer) OR (t IS Types.Procedure)
END matchesToNIL;

PROCEDURE areTypesMatch*(t1: Types.PType; t2: Types.PType): BOOLEAN;
    RETURN areTypesExactlyMatch(t1, t2)
        OR (Types.isInt(t1) & Types.isInt(t2))
        OR (((t1 = Types.nil) & (matchesToNIL(t2^)))
            OR ((t2 = Types.nil) & (matchesToNIL(t1^))))
END areTypesMatch;

PROCEDURE areArgsMatch(a1, a2: Types.PProcedureArgument; p1, p2: Types.PDefinedProcedure): BOOLEAN;
    RETURN (a1.isVar = a2.isVar)
        & (    ((a1.type = p1) & (a2.type = p2))
            OR areTypesExactlyMatch(a1.type, a2.type))
END areArgsMatch;

PROCEDURE areProceduresMatch*(p1, p2: Types.PDefinedProcedure): BOOLEAN;
VAR
    result: BOOLEAN;
BEGIN
    args1 <- p1.args();
    args2 <- p2.args();
    argsLen <- LEN(args1);
    IF LEN(args2) = argsLen THEN
        i <- 0;
        WHILE (i < argsLen) 
            & areArgsMatch(args1[i], args2[i], p1, p2) DO
            INC(i);
        END;
        IF i = argsLen THEN
            r1 <- p1.result();
            r2 <- p2.result();
            result := ((r1 = p1) & (r2 = p2)) OR areTypesExactlyMatch(r1, r2);
        END;
    END;
    RETURN result
END areProceduresMatch;

PROCEDURE areTypesExactlyMatchImpl(t1: Types.PType; t2: Types.PType): BOOLEAN;
VAR
    result: BOOLEAN;
BEGIN
    IF t1 = t2 THEN
        result := TRUE;
    ELSIF (t1 IS Types.PArray) & (t2 IS Types.POpenArray) THEN
        result := areTypesMatch(Types.arrayElementsType(t1^), 
                                Types.arrayElementsType(t2^));
    ELSIF (t1 IS Types.PStaticArray) & (t2 IS Types.PStaticArray) THEN
        result := (t1.length() = t2.length()) 
                & (areTypesMatch(Types.arrayElementsType(t1^), 
                                 Types.arrayElementsType(t2^)));
    ELSIF (t1 IS Types.PPointer) & (t2 IS Types.PPointer) THEN
        result := areTypesMatch(Types.pointerBase(t1^), 
                                Types.pointerBase(t2^));
    ELSIF (t1 IS Types.PDefinedProcedure) & (t2 IS Types.PDefinedProcedure) THEN
        result := areProceduresMatch(t1, t2);
    END;
    RETURN result
END areTypesExactlyMatchImpl;

PROCEDURE CastOpDoNothing.make(rtl: OberonRtl.PType; e: Code.PExpression): Code.PExpression;
    RETURN e
END CastOpDoNothing.make;

PROCEDURE passedByReference*(e: Code.PExpression): BOOLEAN;
BEGIN
    info <- e.designator().info();
    RETURN (info IS Types.PVariable) & info.isReference();
END;

PROCEDURE assignByReference*(left, right: Code.PExpression): STRING;
    RETURN left.code() + ".set(" + Code.derefExpression(right).code() + ")";
END;

PROCEDURE CastOpDoNothing.assign(rtl: OberonRtl.PType; left, right: Code.PExpression): STRING;
VAR
    result: STRING;
BEGIN
    rightConverted <- SELF.make(rtl, right);
    IF passedByReference(left) THEN
        result := assignByReference(left, rightConverted);
    ELSE
        result := left.lval() + " = " + Code.derefExpression(rightConverted).code();
    END;
    RETURN result;
END;

PROCEDURE cloneArray*(t: Types.Array; code: STRING; rtl: OberonRtl.Type): STRING;
VAR
    result: STRING;
BEGIN
    IF Types.isScalar(Types.arrayElementsType(t)^) THEN
        result := code + ".slice()";
    ELSIF Types.isScalar(Types.arrayBaseElementsType(t)^) THEN 
        result := rtl.cloneArrayOfScalars(code);
    ELSE
        result := rtl.cloneArrayOfRecords(code);
    END;
    RETURN result
END cloneArray;

PROCEDURE CastOpArray.assign(rtl: OberonRtl.PType; left, right: Code.PExpression): STRING;
    RETURN left.code() + " = " + cloneArray(right.type()(Types.PArray)^, right.code(), rtl^)
END CastOpArray.assign;

PROCEDURE CastOpRecord.assign(rtl: OberonRtl.PType; left, right: Code.PExpression): STRING;
    RETURN rtl.copyRecord(right.code(), left.code())
END CastOpRecord.assign;

PROCEDURE CastOpStrToChar.make(rtl: OberonRtl.PType; e: Code.PExpression): Code.PExpression;
BEGIN
    s <- e.type()(Types.PString);
    ASSERT(LEN(s.s) = 1);
    c <- s.s[0];
    code <- String.fromInt(ORD(c))
    RETURN Code.makeSimpleExpression(code, Types.basic.ch)
END CastOpStrToChar.make;

PROCEDURE implicit*(from, to: Types.PType; toVar: BOOLEAN; ops: Operations; VAR op: PCastOp): INTEGER;
VAR
    ignore: BOOLEAN;
BEGIN
    result <- err;
    op := NIL;
    IF from = to THEN
        IF from IS Types.PRecord THEN
            op := castOpRecord;
        ELSIF from IS Types.PArray THEN
            op := castOpArray;
        END;
        result := errNo;
    ELSIF (from = Types.basic.uint8) & (to = Types.basic.integer) THEN
        IF toVar THEN
            result := errVarParameter;
        ELSE
            result := errNo;
        END;
    ELSIF (from = Types.basic.integer) & (to = Types.basic.uint8) THEN
        IF toVar THEN
            result := errVarParameter;
        ELSE
            op := ops.castToUint8;
            result := errNo;
        END;
    ELSIF from IS Types.PString THEN
        IF to = Types.basic.ch THEN
            IF LEN(from.s) = 1 THEN
                op := castOpStrToChar;
                result := errNo;
            END;
        ELSIF Types.isString(to) THEN
            result := errNo;
        END;
    ELSIF (from IS Types.PArray) & (to IS Types.POpenArray)
        & areTypesExactlyMatch(Types.arrayElementsType(from^), 
                               Types.arrayElementsType(to^)) THEN
            result := errNo;
    ELSIF (from IS Types.PStaticArray) & (to IS Types.PStaticArray) 
        & (from.length() = to.length())
        & areTypesExactlyMatch(Types.arrayElementsType(from^), 
                               Types.arrayElementsType(to^)) THEN
            op := castOpArray;
            result := errNo;
    ELSIF (from IS Types.PPointer) & (to IS Types.PPointer) THEN
        IF ~toVar THEN
            IF findPointerBaseType(to, from^) # NIL THEN
                result := errNo;
            END;
        ELSIF areTypesExactlyMatchImpl(to, from) THEN
            result := errNo;
        ELSE
            result := errVarParameter;
        END;
    ELSIF (from IS Types.PRecord) & (to IS Types.PRecord) THEN
        IF findBaseType(to, from) # NIL THEN
            op := castOpRecord;
            result := errNo;
        END;
    ELSIF (from = Types.nil) & matchesToNIL(to^) THEN
        result := errNo;
    ELSIF (from IS Types.PDefinedProcedure) & (to IS Types.PDefinedProcedure) THEN
        IF areProceduresMatch(from, to) THEN
            result := errNo;
        END
    END;

    IF (result = errNo) & (op = NIL) THEN
        op := doNothing;
    END;
    RETURN result
END implicit;

BEGIN
    areTypesExactlyMatch := areTypesExactlyMatchImpl;
    NEW(doNothing);
    NEW(castOpArray);
    NEW(castOpRecord);
    NEW(castOpStrToChar);
END Cast.
