MODULE Types;
IMPORT
    Context, Errors, JS, Object, ScopeBase, Str := String;
TYPE
    Id* = RECORD(Object.Type)
        PROCEDURE idType*(): STRING
    END;

    PId* = POINTER TO Id;
    
    Type* = RECORD(Object.Type)
        PROCEDURE description*(): STRING
    END;
    PType* = POINTER TO Type;

    TypeId* = RECORD(Id)
        PROCEDURE TypeId*(type: PType);

        PROCEDURE type*(): PType;
        PROCEDURE description(): STRING;
        PROCEDURE strip();

        mType: PType
    END;
    PTypeId* = POINTER TO TypeId;

    ResolveTypeCallback = PROCEDURE(): PType;

    ForwardTypeId* = RECORD(TypeId)
        PROCEDURE ForwardTypeId(resolve: ResolveTypeCallback);

        resolve: ResolveTypeCallback
    END;

    PForwardTypeId = POINTER TO ForwardTypeId;

    LazyTypeId* = RECORD(TypeId)
        PROCEDURE LazyTypeId*();
    END;

    PLazyTypeId = POINTER TO LazyTypeId;

    Const* = RECORD(Id)
        PROCEDURE Const*(type: PType; value: JS.var);

        type: PType;
        value: JS.var
    END;

    PConst* = POINTER TO Const;

    Variable* = RECORD(Id)
        PROCEDURE type*(): PType;
        PROCEDURE isReadOnly*(): BOOLEAN;
        PROCEDURE isReference*(): BOOLEAN
    END;

    PVariable* = POINTER TO Variable;

    VariableImpl = RECORD(Variable)
        PROCEDURE VariableImpl(type: PType; ref: BOOLEAN);

        mType: PType;
        mRef: BOOLEAN
    END;
    PVariableImpl = POINTER TO VariableImpl;

    ReadOnlyVariable = RECORD(VariableImpl)
        PROCEDURE ReadOnlyVariable(type: PType);
    END;

    ExportedVariable = RECORD(ReadOnlyVariable)
    END;

    PExportedVariable = POINTER TO ExportedVariable;

    ProcedureId* = RECORD(Id)
        PROCEDURE ProcedureId*(type: PType);

        type*: PType
    END;

    PProcedureId* = POINTER TO ProcedureId;

    String* = RECORD(Type)
        PROCEDURE String*(s: STRING);

        s-: STRING
    END;

    PString* = POINTER TO String;

    FieldCode* = RECORD
        PROCEDURE FieldCode*(code, derefCode, propCode: STRING);

        code, derefCode, propCode: STRING;
    END;
    PFieldCode* = POINTER TO FieldCode;

    Field* = RECORD(Object.Type)
        PROCEDURE id*(): STRING;
        PROCEDURE exported*(): BOOLEAN;
        PROCEDURE type*(): PType;
        PROCEDURE asVar*(isReadOnly: BOOLEAN; cx: Context.Type): PId;
        PROCEDURE designatorCode*(leadCode: STRING; cx: Context.Type): PFieldCode;
    END;
    PField* = POINTER TO Field;

    PStorageType* = POINTER TO StorageType;

    RecordField* = RECORD(Field)
        PROCEDURE RecordField*(identdef: Context.PIdentdefInfo; type: PStorageType);

        PROCEDURE identdef*(): Context.PIdentdefInfo;

        mIdentdef: Context.PIdentdefInfo;
        mType: PStorageType;
    END;
    PRecordField* = POINTER TO RecordField;

    StorageType* = RECORD(Type)    
        PROCEDURE initializer*(cx: Context.Type): STRING;
        PROCEDURE denote*(id: STRING; isReadObly: BOOLEAN): PField;
        PROCEDURE isScalar*(): BOOLEAN;
    END;

    NamedType* = RECORD(StorageType)
        PROCEDURE NamedType(name: STRING);

        name*: STRING
    END;

    Array* = RECORD(NamedType)
        PROCEDURE Array*(elementsType: PStorageType);

        elementsType-: PStorageType
    END;
    PArray* = POINTER TO Array;

    OpenArray* = RECORD(Array)
    END;
    POpenArray* = POINTER TO OpenArray;

    StaticArray* = RECORD(Array)
        PROCEDURE StaticArray*(initializer: STRING; elementsType: PStorageType; len: INTEGER); 

        PROCEDURE length*(): INTEGER;

        mInitializer: STRING;
        len: INTEGER
    END;
    PStaticArray* = POINTER TO StaticArray;

    PRecord* = POINTER TO Record;

    Pointer* = RECORD(NamedType)
        PROCEDURE Pointer*(name: STRING; base: PTypeId);

        base: PTypeId
    END;

    PPointer* = POINTER TO Pointer;

    Procedure* = RECORD(NamedType)
        PROCEDURE designatorCode*(id: STRING): STRING
    END;
    PProcedure* = POINTER TO Procedure;

    ProcedureArgument* = RECORD (Object.Type)
        PROCEDURE ProcedureArgument*(type: PType; isVar: BOOLEAN);

        PROCEDURE description(): STRING;

        type*: PType;
        isVar*: BOOLEAN
    END;

    PProcedureArgument* = POINTER TO ProcedureArgument;
    ProcedureArguments* = ARRAY * OF PProcedureArgument;

    DefinedProcedure* = RECORD(Procedure)
        PROCEDURE args*(): ProcedureArguments;
        PROCEDURE result*(): PType
    END;
    PDefinedProcedure* = POINTER TO DefinedProcedure;

    BasicType* = RECORD(NamedType)
        PROCEDURE BasicType*(name: STRING; initializer: STRING);

        mInitializer: STRING
    END;

    PBasicType* = POINTER TO BasicType;

    FieldsMap = MAP OF PField;

    Record* = RECORD(NamedType)
        PROCEDURE Record*(name: STRING; cons: STRING; scope: ScopeBase.PType);

        PROCEDURE setBase*(type: PRecord);
        PROCEDURE addField*(f: PField);
        PROCEDURE findSymbol*(id: STRING): PField;
        PROCEDURE codeForNew*(cx: Context.Type): STRING;
        PROCEDURE finalize*();

        fields-: FieldsMap;
        base-:   PRecord;
        cons-:   STRING;
        scope-:  ScopeBase.PType;
        notExported: ARRAY * OF STRING
    END;
    
    NonExportedRecord* = RECORD(Record)
        PROCEDURE NonExportedRecord(cons: STRING; scope: ScopeBase.PType; base: PRecord);
    END;
    PNonExportedRecord* = POINTER TO NonExportedRecord;

    Nil = RECORD(Type)
    END;

    Module* = RECORD(Id)
        PROCEDURE Module*(name: STRING);

        name: STRING
    END;

    PModule* = POINTER TO Module;

    ArrayDimensionDescriptionCallback = PROCEDURE(VAR a: Array): STRING;

VAR
    basic*: RECORD
        bool*, ch*, integer*, uint8*, real*, set*: PBasicType
    END;

    numeric*: ARRAY * OF PType;
    nil*: POINTER TO Nil;

    pGenerateTypeInfo: PROCEDURE(type: PType): STRING;

PROCEDURE TypeId.description(): STRING;
VAR
    t: PType;
BEGIN
    t := SELF.type();
    RETURN "type " + t.description()
END TypeId.description;

PROCEDURE TypeId.type(): PType;
    RETURN SELF.mType
END TypeId.type;

PROCEDURE finalizeRecord(closure: Object.PType);
BEGIN
    closure(PRecord).finalize();
END finalizeRecord;

PROCEDURE Record.codeForNew(cx: Context.Type): STRING;
    RETURN SELF.initializer(cx);
END;

PROCEDURE Record.finalize();
BEGIN
    FOR i <- 0 TO LEN(SELF.notExported) - 1 DO
        SELF.fields.remove(SELF.notExported[i])
    END;
    SELF.notExported.clear();
END Record.finalize;

PROCEDURE Record.isScalar(): BOOLEAN;
    RETURN FALSE;
END;

PROCEDURE recordOwnFields*(r: Record): FieldsMap;
    RETURN r.fields;
END;

PROCEDURE Record.Record(name: STRING; cons: STRING; scope: ScopeBase.PType)
    | SUPER(name),
      cons(cons),
      scope(scope);
BEGIN
    scope.addFinalizer(finalizeRecord, SELF(POINTER));
END;

PROCEDURE NonExportedRecord.NonExportedRecord(cons: STRING; scope: ScopeBase.PType; base: PRecord)
    | SUPER("", cons, scope);
BEGIN
    SELF.base := base;
END;    

PROCEDURE TypeId.strip();
VAR
    r: PRecord;
BEGIN
    IF SELF.mType IS PRecord THEN
        r := SELF.mType(PRecord);
        SELF.mType := NEW NonExportedRecord(r.cons, r.scope, r.base);
    ELSE
        SELF.mType := NIL;
    END;
END TypeId.strip;

PROCEDURE ForwardTypeId.ForwardTypeId(resolve: ResolveTypeCallback)
    | SUPER(NIL),
      resolve(resolve);
END;

PROCEDURE ForwardTypeId.type(): PType;
BEGIN
    IF SELF.mType = NIL THEN
        SELF.mType := SELF.resolve();
    END;
    RETURN SELF.mType
END ForwardTypeId.type;

PROCEDURE defineTypeId*(VAR tId: LazyTypeId; t: PType);
BEGIN
    tId.mType := t;
END defineTypeId;

PROCEDURE typeName*(type: NamedType): STRING;
    RETURN type.name
END typeName;

PROCEDURE ProcedureId.idType(): STRING;
    RETURN "procedure"
END ProcedureId.idType;

PROCEDURE String.description(): STRING;
VAR
    prefix: STRING;
BEGIN
    IF LEN(SELF.s) = 1 THEN
        prefix := "single-";
    ELSE
        prefix := "multi-";
    END;
    RETURN prefix + "character string"
END String.description;

PROCEDURE stringValue*(s: String): STRING;
    RETURN s.s
END stringValue;

PROCEDURE stringLen*(s: String): INTEGER;
    RETURN LEN(s.s)
END stringLen;

PROCEDURE stringAsChar*(s: String; VAR c: CHAR): BOOLEAN;
VAR
    result: BOOLEAN;
BEGIN
    result := stringLen(s) = 1;
    IF result THEN
        c := s.s[0];
    END;
    RETURN result
END stringAsChar;

PROCEDURE Const.idType(): STRING;
    RETURN "constant"
END Const.idType;

PROCEDURE constType*(c: Const): PType;
    RETURN c.type
END constType;

PROCEDURE constValue*(c: Const): JS.var;
    RETURN c.value
END constValue;

PROCEDURE Variable.idType(): STRING;
    RETURN "variable"
END Variable.idType;

PROCEDURE ReadOnlyVariable.ReadOnlyVariable(type: PType)
    | SUPER(type, FALSE);
END;

PROCEDURE ReadOnlyVariable.idType(): STRING;
    RETURN "read-only variable"
END ReadOnlyVariable.idType;

PROCEDURE VariableImpl.type(): PType;
    RETURN SELF.mType
END VariableImpl.type;

PROCEDURE VariableImpl.isReference(): BOOLEAN;
    RETURN SELF.mRef
END VariableImpl.isReference;

PROCEDURE procedureType*(p: ProcedureId): PType;
    RETURN p.type
END procedureType;

PROCEDURE Variable.isReadOnly(): BOOLEAN;
    RETURN FALSE
END Variable.isReadOnly;

PROCEDURE ReadOnlyVariable.isReadOnly(): BOOLEAN;
    RETURN TRUE
END ReadOnlyVariable.isReadOnly;

PROCEDURE ExportedVariable.idType(): STRING;
    RETURN "imported variable"
END ExportedVariable.idType;

PROCEDURE TypeId.idType(): STRING;
    RETURN "type"
END TypeId.idType;

PROCEDURE BasicType.description(): STRING;
    RETURN SELF.name
END BasicType.description;

PROCEDURE BasicType.initializer(cx: Context.Type): STRING;
    RETURN SELF.mInitializer
END BasicType.initializer;

PROCEDURE BasicType.isScalar(): BOOLEAN;
    RETURN TRUE;
END;

PROCEDURE Nil.description(): STRING;
    RETURN "NIL"
END Nil.description;

PROCEDURE isInt*(t: PType): BOOLEAN;
    RETURN (t = basic.integer) OR (t = basic.uint8)
END isInt;

PROCEDURE intsDescription*(): STRING;
    RETURN "'INTEGER' or 'BYTE'"
END intsDescription;

PROCEDURE isString*(t: PType): BOOLEAN;
    RETURN ((t IS PArray) & (t.elementsType = basic.ch))
           OR (t^ IS String)
END isString;

PROCEDURE moduleName*(m: Module): STRING;
    RETURN m.name
END moduleName;

PROCEDURE BasicType.BasicType(name: STRING; initializer: STRING)
    | SUPER(name),
      mInitializer(initializer);
END;

PROCEDURE Record.description(): STRING;
VAR
    result: STRING;
BEGIN
    IF LEN(SELF.name) # 0 THEN
        result := SELF.name;
    ELSE
        result := "anonymous RECORD";
    END;
    RETURN result
END Record.description;

PROCEDURE recordConstructor*(cx: Context.Type; r: Record): STRING;
    RETURN cx.qualifyScope(r.scope) + r.cons;
END;

PROCEDURE recordInitializer*(cx: Context.Type; r: Record; args: STRING): STRING;
    RETURN "new " + recordConstructor(cx, r)  + "(" + args + ")";
END;

PROCEDURE Record.initializer(cx: Context.Type): STRING;
    RETURN recordInitializer(cx, SELF, "");
END;

PROCEDURE Record.addField(f: PField);
BEGIN
    IF f.id() IN SELF.fields THEN
        Errors.raise("duplicated field: '" + f.id() + "'");
    END;
    IF (SELF.base # NIL) & (SELF.base.findSymbol(f.id()) # NIL) THEN
        Errors.raise("base record already has field: '" + f.id() + "'");
    END;
    SELF.fields[f.id()] := f;
    IF ~f.exported() THEN
        SELF.notExported.add(f.id());
    END;
END Record.addField;

PROCEDURE Record.findSymbol(id: STRING): PField;
VAR
    result: PField;
BEGIN
    IF id IN SELF.fields THEN
        result := SELF.fields[id];
    ELSIF SELF.base # NIL THEN
        result := SELF.base.findSymbol(id);
    END;
    RETURN result;
END;

PROCEDURE existingField(r: Record; id: STRING; d: NamedType): PField;
BEGIN
    result <- r.findSymbol(id);
    IF result = NIL THEN
        Errors.raise("type '" + d.description() + "' has no '" + id + "' field");
    END;
    RETURN result
END existingField;

PROCEDURE Record.denote(id: STRING; isReadObly: BOOLEAN): PField;
BEGIN
    RETURN existingField(SELF, id, SELF)
END;

PROCEDURE recordBase*(r: Record): PRecord;
    RETURN r.base
END recordBase;

PROCEDURE Record.setBase(type: PRecord);
BEGIN
    SELF.base := type;
END;

PROCEDURE recordScope*(r: Record): ScopeBase.PType;
    RETURN r.scope
END recordScope;

PROCEDURE pointerBase*(p: Pointer): PRecord;
VAR
    result: PType;
BEGIN
    result := p.base.type();
    RETURN result(PRecord)
END pointerBase;

PROCEDURE Pointer.description(): STRING;
VAR
    base: PRecord;
    result: STRING;
BEGIN
    IF LEN(SELF.name) # 0 THEN
        result := SELF.name;
    ELSE
        base := pointerBase(SELF);
        result := "POINTER TO " + base.description();
    END;
    RETURN result
END Pointer.description;

PROCEDURE Pointer.initializer(cx: Context.Type): STRING;
    RETURN "null"
END Pointer.initializer;

PROCEDURE Pointer.denote(id: STRING; isReadObly: BOOLEAN): PField;
VAR
    d: POINTER TO NamedType;
BEGIN
    base <- pointerBase(SELF);
    IF (LEN(SELF.name) = 0) OR (LEN(base.name) # 0) THEN
        d := base;
    ELSE
        d := SELF(POINTER);
    END;
    RETURN existingField(base^, id, d^)
END;

PROCEDURE Pointer.isScalar(): BOOLEAN;
    RETURN TRUE;
END;

PROCEDURE foldArrayDimensions(VAR a: Array; dimToStr: ArrayDimensionDescriptionCallback; VAR sizes, of: STRING);
BEGIN  
    elementsType <- a.elementsType;
    IF ~(a IS OpenArray) & (elementsType IS PArray) THEN
        foldArrayDimensions(elementsType^, dimToStr, sizes, of);
        sizes := dimToStr(a) + ", " + sizes;
    ELSE
        sizes := dimToStr(a);
        of := a.elementsType.description();
    END
END foldArrayDimensions;

PROCEDURE arrayDimensionDescription*(VAR a: Array): STRING;
VAR
    result: STRING;
BEGIN
    IF a IS StaticArray THEN
        result := Str.fromInt(a.length());
    END;
    RETURN result
END arrayDimensionDescription;

PROCEDURE arrayDescription*(VAR a: Array; dimToStr: ArrayDimensionDescriptionCallback): STRING;
VAR
    result: STRING;
    sizes, of: STRING;
BEGIN
    IF a.elementsType = NIL THEN (* special arrays, see procedure "LEN" *)
        result := a.name;
    ELSE
        foldArrayDimensions(a, dimToStr, sizes, of);
        IF LEN(sizes) # 0 THEN
            sizes := " " + sizes;
        END;
        result := "ARRAY" + sizes + " OF " + of;
    END;
    RETURN result
END arrayDescription;

PROCEDURE Array.description(): STRING;
    RETURN arrayDescription(SELF, arrayDimensionDescription)
END;

PROCEDURE Array.isScalar(): BOOLEAN;
    RETURN FALSE;
END;

PROCEDURE StorageType.denote(id: STRING; isReadObly: BOOLEAN): PField;
BEGIN
    Errors.raise("selector '." + id + "' cannot be applied to '" 
               + SELF.description() + "'");
    RETURN NIL
END;

PROCEDURE OpenArray.initializer(cx: Context.Type): STRING;
    RETURN ""
END OpenArray.initializer;

PROCEDURE StaticArray.initializer(cx: Context.Type): STRING;
    RETURN SELF.mInitializer
END StaticArray.initializer;

PROCEDURE arrayElementsType*(a: Array): PStorageType;
    RETURN a.elementsType
END arrayElementsType;

PROCEDURE StaticArray.length(): INTEGER;
    RETURN SELF.len
END StaticArray.length;

PROCEDURE Procedure.initializer(cx: Context.Type): STRING;
    RETURN "null"
END Procedure.initializer;

PROCEDURE Procedure.description(): STRING;
    RETURN SELF.name
END Procedure.description;

PROCEDURE Procedure.isScalar(): BOOLEAN;
    RETURN TRUE;
END;

PROCEDURE DefinedProcedure.designatorCode(id: STRING): STRING;
    RETURN id
END DefinedProcedure.designatorCode;

PROCEDURE ProcedureArgument.description(): STRING;
VAR
    result: STRING;
BEGIN
    IF SELF.isVar THEN
        result := "VAR ";
    END;
    RETURN result + SELF.type.description()
END ProcedureArgument.description;

PROCEDURE ProcedureArgument.ProcedureArgument(type: PType; isVar: BOOLEAN)
    | type(type),
      isVar(isVar);
END;

PROCEDURE Module.idType(): STRING;
    RETURN "MODULE"
END Module.idType;

PROCEDURE TypeId.TypeId(type: PType)
    | mType(type);
END;

PROCEDURE LazyTypeId.LazyTypeId()
    | SUPER(NIL);
END;

PROCEDURE String.String(s: STRING)
    | s(s);
END;

PROCEDURE NamedType.NamedType(name: STRING)
    | name(name);
END;

PROCEDURE Array.Array(elementsType: PStorageType)
    | SUPER(""),
      elementsType(elementsType);
BEGIN
END;

PROCEDURE StaticArray.StaticArray(
    initializer: STRING;
    elementsType: PStorageType;
    len: INTEGER ) | 
    SUPER(elementsType),
    mInitializer(initializer),
    len(len);
END;

PROCEDURE Pointer.Pointer(name: STRING; base: PTypeId)
    | SUPER(name),
      base(base);
END;

PROCEDURE Const.Const(type: PType; value: JS.var)
    | type(type),
      value(value);
END;

PROCEDURE VariableImpl.VariableImpl(type: PType; ref: BOOLEAN)
    | mType(type),
      mRef(ref);
END;

PROCEDURE makeVariable*(type: PType; readOnly: BOOLEAN): PVariable;
VAR
    result: PVariableImpl;
BEGIN
    IF readOnly THEN
        result := NEW ReadOnlyVariable(type);
    ELSE
        result := NEW VariableImpl(type, FALSE);
    END;
    RETURN result
END makeVariable;

PROCEDURE makeVariableRef*(type: PType): PVariable;
    RETURN NEW VariableImpl(type, TRUE);
END;

PROCEDURE makeExportedVariable*(v: Variable): PVariable;
    RETURN NEW ExportedVariable(v.type());
END;

PROCEDURE ProcedureId.ProcedureId(type: PType)
    | type(type);
END;

PROCEDURE Module.Module(name: STRING)
    | name(name);
END;

PROCEDURE FieldCode.FieldCode(code, derefCode, propCode: STRING)
    | code(code), derefCode(derefCode), propCode(propCode);
END;

PROCEDURE mangleJSProperty*(id: STRING): STRING;
BEGIN
    result <- id;
    IF (id = "constructor") OR (id = "prototype") THEN
        result := result + "$";
    END;
    RETURN result;
END;

PROCEDURE mangleField*(id: STRING): STRING;
    RETURN mangleJSProperty(id);
END;

PROCEDURE RecordField.id(): STRING;
    RETURN SELF.mIdentdef.id();
END;

PROCEDURE RecordField.exported(): BOOLEAN;
    RETURN SELF.mIdentdef.exported();
END;

PROCEDURE RecordField.identdef(): Context.PIdentdefInfo;
    RETURN SELF.mIdentdef;
END;

PROCEDURE RecordField.designatorCode(leadCode: STRING; cx: Context.Type): PFieldCode;
CONST
    kQuote = 22X;
BEGIN
    codeId <- mangleField(SELF.mIdentdef.id());
    RETURN NEW FieldCode(leadCode + "." + codeId, leadCode, kQuote + codeId + kQuote);
END;

PROCEDURE RecordField.type(): PType;
    RETURN SELF.mType;
END;

PROCEDURE RecordField.asVar(isReadOnly: BOOLEAN; cx: Context.Type): PId;
    RETURN makeVariable(SELF.mType, isReadOnly);
END;

PROCEDURE RecordField.RecordField(identdef: Context.PIdentdefInfo; type: PStorageType)
    | mIdentdef(identdef),
      mType(type);
END;

PROCEDURE dumpRecordFields*(type: PRecord): STRING;
VAR
    result: STRING;
BEGIN
    IF type.base # NIL THEN
        result := dumpRecordFields(type.base);
    END;
    FOREACH v, k IN type.fields DO
        IF LEN(result) # 0 THEN
            result := result + ", ";
        END;
        result := result + mangleField(k) + ": " + pGenerateTypeInfo(v.type());
    END;
    RETURN result;
END;

PROCEDURE generateTypeInfo*(type: PType): STRING;
VAR
    result: STRING;
BEGIN
    IF type IS PRecord THEN
        result := "{record: {" + dumpRecordFields(type) + "}}";
    ELSIF type IS PArray THEN
        result := "{array: " + generateTypeInfo(type.elementsType) + "}";
    ELSE
        result := "null";
    END;
    RETURN result;
END;

BEGIN
    basic.bool := NEW BasicType("BOOLEAN", "false");
    basic.ch := NEW BasicType("CHAR", "0");
    basic.integer := NEW BasicType("INTEGER", "0");
    basic.uint8 := NEW BasicType("BYTE", "0");
    basic.real := NEW BasicType("REAL", "0");
    basic.set := NEW BasicType("SET", "0");

    numeric.add(basic.integer);
    numeric.add(basic.uint8);
    numeric.add(basic.real);

    NEW(nil);

    pGenerateTypeInfo := generateTypeInfo;
END Types.
