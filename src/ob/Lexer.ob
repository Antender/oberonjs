MODULE Lexer;
IMPORT Context, Errors, Stream, String;

CONST
    quote = 22X; (* " *)
    commentBegin = "(*";
    commentEnd = "*)";

    jsReservedWords 
        = "break case catch const continue debugger default delete do else finally "
        + "for function if in instanceof new return switch this throw try typeof "
        + "var void while with false true null class enum export extends "
        + "import super implements interface let package private protected "
        + "public static yield "
        + "Object Math Number" (* Object, Math and Number are used in generated code for some functions so it is 
                    reserved word from code generator standpoint *)
        ;

TYPE
    Literal* = RECORD
        PROCEDURE Literal*(s: STRING);

        s: STRING
    END;

PROCEDURE isDigit(c: CHAR): BOOLEAN;
    RETURN (c >= "0") & (c <= "9")
END isDigit;

PROCEDURE isLetter(c: CHAR): BOOLEAN;
    RETURN ((c >= "a") & (c <= "z")) OR ((c >= "A") & (c <= "Z"))
END isLetter;

PROCEDURE digit*(VAR stream: Stream.Type; context: Context.Type): BOOLEAN;
VAR
    result: BOOLEAN;
    c: CHAR;
BEGIN
    IF ~Stream.eof(stream) THEN
        c := Stream.getChar(stream);
        IF isDigit(c) THEN
            context.handleChar(c);
            result := TRUE;
        END
    END
    RETURN result
END digit;

PROCEDURE integer*(VAR stream: Stream.Type; VAR context: Context.Type): BOOLEAN;
VAR
    hexDetected: BOOLEAN;
    dec, hex: INTEGER;

    PROCEDURE collect(c: CHAR): BOOLEAN;
    BEGIN
        d <- -1;
        IF (c >= "0") & (c <= "9") THEN
            d := ORD(c) - ORD("0");
        ELSIF (c >= "A") & (c <= "F") THEN
            d := ORD(c) - ORD("A") + 10;
            hexDetected := TRUE;
        END;
        IF d # -1 THEN
            hex := hex * 16 + d;
            IF ~hexDetected THEN
                dec := dec * 10 + d;
            END;
        END;
        RETURN d # -1;
    END;

BEGIN
    result <- FALSE;
    IF ~Stream.eof(stream) & collect(Stream.getChar(stream)) & ~hexDetected THEN
        WHILE ~Stream.eof(stream) & collect(Stream.peekChar(stream)) DO
            Stream.next(stream, 1);
        END;
        IF ~Stream.eof(stream) & (Stream.peekChar(stream) = "H") THEN
            hexDetected := TRUE;
            Stream.next(stream, 1);
        ELSIF hexDetected THEN
            Errors.raise("integer constant looks like having hexadecimal format but 'H' suffix is missing");
        END;

        IF Stream.eof(stream) OR ~isLetter(Stream.peekChar(stream)) THEN
            IF hexDetected THEN
                context.attributes["int"] := hex;
            ELSE
                context.attributes["int"] := dec;
            END;
        
            result := TRUE;
        END;
    END
    RETURN result;
END;

PROCEDURE hexDigit*(VAR stream: Stream.Type; context: Context.Type): BOOLEAN;
VAR
    result: BOOLEAN;
    c: CHAR;
BEGIN
    c := Stream.getChar(stream);
    IF isDigit(c) OR ((c >= "A") & (c <= "F")) THEN
        context.handleChar(c);
        result := TRUE;
    END
    RETURN result
END hexDigit;

PROCEDURE point*(VAR stream: Stream.Type; context: Context.Type): BOOLEAN;
VAR result: BOOLEAN;
BEGIN
    IF    ~Stream.eof(stream)
        & (Stream.getChar(stream) = ".")
        & (    Stream.eof(stream) 
            OR (Stream.peekChar(stream) # ".")) THEN (*not a diapason ".."*)        
        context.handleLiteral(".");
        result := TRUE;
    END
    RETURN result;
END;

PROCEDURE string*(VAR stream: Stream.Type; context: Context.Type): BOOLEAN;
VAR
    result: BOOLEAN;
    c: CHAR;
    s: STRING;
BEGIN
    IF ~Stream.eof(stream) THEN
        c := Stream.getChar(stream);
        IF c = quote THEN
            IF ~Stream.eof(stream) THEN
                c := Stream.getChar(stream);
                WHILE (c # quote) & ~Stream.eof(stream) DO
                    IF c # quote THEN
                        s := s + String.fromChar(c);
                    END;
                    c := Stream.getChar(stream);
                END;
            ELSE
                c := 0X;
            END;
            IF c # quote THEN
                Errors.raise("unexpected end of string");
            END;
            context.handleString(s);
            result := TRUE;
        END
    END
    RETURN result
END string;

PROCEDURE isReservedWord(s: STRING; words: STRING): BOOLEAN;
VAR
    i, w: INTEGER;
BEGIN
    WHILE (w < LEN(words))
        & (i < LEN(s))
        & (words[w] = s[i])
        & ((i # 0) OR (w = 0) OR (words[w - 1] = " ")) DO
        INC(w);
        INC(i);
    ELSIF (w < LEN(words)) 
        & ((i < LEN(s)) OR (words[w] # " ")) DO
        INC(w);
        i := 0;
    END;
    RETURN i = LEN(s)
END isReservedWord;

PROCEDURE ident*(VAR stream: Stream.Type; context: Context.Type; reservedWords: STRING): BOOLEAN;
VAR
    result: BOOLEAN;
    c: CHAR;
    s: STRING;
BEGIN
    IF ~Stream.eof(stream) THEN
        c := Stream.getChar(stream);
        IF isLetter(c) THEN
            WHILE ~Stream.eof(stream) & (isLetter(c) OR isDigit(c)) DO (* OR c = "_" *)
                s := s + String.fromChar(c);
                c := Stream.getChar(stream);
            END;
            IF isLetter(c) OR isDigit(c) THEN
                s := s + String.fromChar(c);
            ELSE
                Stream.next(stream, -1);
            END;

            IF ~isReservedWord(s, reservedWords) THEN
                IF isReservedWord(s, jsReservedWords) THEN
                    s := s + "$";
                END;
                context.handleIdent(s);
                result := TRUE;
            END
        END
    END
    RETURN result
END ident;

PROCEDURE skipComment(VAR stream: Stream.Type; context: Context.Type): BOOLEAN;
VAR
    result: BOOLEAN;
BEGIN
    IF Stream.peekStr(stream, commentBegin) THEN
        Stream.next(stream, LEN(commentBegin));
        WHILE ~Stream.peekStr(stream, commentEnd) DO
            IF ~skipComment(stream, context) THEN
                Stream.next(stream, 1);
                IF Stream.eof(stream) THEN
                    Errors.raise("comment was not closed");
                END
            END
        END;
        Stream.next(stream, LEN(commentEnd));
        result := TRUE;
    END
    RETURN result
END skipComment;

PROCEDURE readSpaces(c: CHAR): BOOLEAN;
    RETURN (c = " ") 
        OR (c = 8X)
        OR (c = 9X)
        OR (c = 0AX)
        OR (c = 0DX)
END readSpaces;

PROCEDURE skipSpaces*(VAR stream: Stream.Type; context: Context.Type);
BEGIN
    IF (context.isLexem = NIL) OR ~context.isLexem() THEN
        WHILE Stream.read(stream, readSpaces)
            & skipComment(stream, context) DO END;
    END
END skipSpaces;

PROCEDURE Literal.Literal(s: STRING)
    | s(s);
END;

PROCEDURE literal*(l: Literal; VAR stream: Stream.Type; context: Context.Type): BOOLEAN;
VAR
    result: BOOLEAN;
BEGIN
    IF Stream.peekStr(stream, l.s) THEN
        Stream.next(stream, LEN(l.s));
        IF ((context.isLexem # NIL) & context.isLexem())
            OR ~isLetter(l.s[LEN(l.s) - 1])
            OR Stream.eof(stream)
            OR (~isLetter(Stream.peekChar(stream)) & ~isDigit(Stream.peekChar(stream)))
                THEN
            context.handleLiteral(l.s);
            result := TRUE;
        END;
    END;
    RETURN result
END;

END Lexer.
