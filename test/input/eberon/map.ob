MODULE test;
TYPE
    MapOfInteger = MAP OF INTEGER;
VAR
    m: MapOfInteger;

PROCEDURE ForEach();
VAR
    m: MapOfInteger;
BEGIN
    FOREACH v, k IN m DO
        ASSERT(v = 0);
        ASSERT(k # "");
    END;
END;

PROCEDURE makeMap(): MapOfInteger;
VAR
    m: MapOfInteger;
BEGIN
    RETURN m;
END;

PROCEDURE ForEachWithExpression();
BEGIN
    FOREACH v, k IN makeMap() DO
    END;
END;

PROCEDURE NestedForEach();
VAR
    m: MapOfInteger;

    PROCEDURE inner();
    BEGIN
        FOREACH v, k IN m DO
            FOREACH v2, k2 IN m DO
            END;
        END;
    END;
BEGIN
    FOREACH v, k IN m DO
        FOREACH v2, k2 IN m DO
        END;
    END;
    FOREACH v3, k3 IN m DO
        FOREACH v, k IN m DO
        END;
    END;
END;

PROCEDURE put();
TYPE
    T = RECORD 
        field: INTEGER;
    END;
VAR
    m: MapOfInteger;
    s: STRING;
    a: ARRAY 3 OF CHAR;
    mapOfMap: MAP OF MapOfInteger;
    mapOfRecord: MAP OF T;
    mapOfPointer: MAP OF POINTER TO T;
BEGIN
    m["a"] := 1;
    m["abc"] := 2;
    m[s] := 3;
    m[a] := 4;
    mapOfMap["abc"]["cde"] := 5;
    mapOfRecord["abc"].field := 6;
    mapOfPointer["abc"]^ := T();
END;

PROCEDURE in();
VAR
    m: MAP OF INTEGER;
BEGIN
    ASSERT(~("abc" IN m));
END;

PROCEDURE get();
VAR
    m: MapOfInteger;
    s: STRING;
    a: ARRAY 3 OF CHAR;
BEGIN
    ASSERT(m["a"] = 1);
    ASSERT(m["abc"] = 2);
    ASSERT(m[s] = 3);
    ASSERT(m[a] = 4);
END;

PROCEDURE remove();
VAR
    m: MapOfInteger;
BEGIN
    m.remove("abc");
END;

BEGIN
    FOREACH v, k IN m DO
        FOREACH v2, k2 IN m DO
        END;
    END;
END test.